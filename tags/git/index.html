
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="전호진 블로그">
    <title>Tag: git - 전호진 블로그</title>
    <meta name="author" content="Hojin Jun">
    
    
        <link rel="icon" href="https://crynut84.github.io/assets/images/favicon.ico">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="개발하다 마주치는 사소한 일들..">
<meta property="og:type" content="blog">
<meta property="og:title" content="전호진 블로그">
<meta property="og:url" content="https://crynut84.github.io/tags/git/index.html">
<meta property="og:site_name" content="전호진 블로그">
<meta property="og:description" content="개발하다 마주치는 사소한 일들..">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="전호진 블로그">
<meta name="twitter:description" content="개발하다 마주치는 사소한 일들..">
<meta name="twitter:creator" content="@crynut84">
    
    
        
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=640"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-63739974-1', 'auto');
        ga('send', 'pageview');
    </script>


        
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">전호진 블로그</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=90" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=110" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Hojin Jun</h4>
                
                    <h5 class="sidebar-profile-bio"></h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/crynut84" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.facebook.com/hojin.jun" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/19/basic-command-git/">
                            git 기초 명령어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-19T08:52:48+09:00">
	
		    2015-06-19
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><a href="http://crynut84.github.io/2015-06-16/install-git.html">git을 설치</a>했다면 내 로컬에 완전한 git repository를 가질 수 있다는 것을 의미한다. 그럼 git을 이용해 어떻게 repository를 만들고 관리 할 수 있는지 기초 명령어를 알아보자.</p>
<p>아래와 같은 명령어를 다룰 것이다.</p>
<ul>
<li><a href="#git-config">git config</a> </li>
<li><a href="#git-init,-git-clone">git init, git-clone</a> </li>
<li><a href="#git-status">git status</a> </li>
<li><a href="#git-add">git add</a> </li>
<li><a href="#git-diff">git diff</a> </li>
<li><a href="#git-commit">git commit</a> </li>
<li><a href="#git-reset">git reset</a> </li>
<li><a href="#git-rm">git rm</a> </li>
<li><a href="#git-mv">git mv</a> </li>
<li><a href="#git-stash">git stash</a> </li>
</ul>
<p>이 11가지 명령어를 배우면 우리는 git을 사용해 프로젝트 파일의 생성, 수정, 삭제, 히스토리 관리를 할 수 있게 된다.</p>
<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>git을 설치하고 나서 제일 처음 할 일은 환경 설정을 하는 것이다. <code>config</code>라는 명령어로 환경 설정을 할 수 있는데 git의 환경 설정은 다음의 3곳에 저장된다.</p>
<ul>
<li>/etc/gitconfig<ul>
<li><code>git config --system</code> 옵션을 주었을 때 사용되는 파일</li>
<li>시스템의 모든 사용자, 모든 repository에 적용</li>
</ul>
</li>
<li>~/.gitconfig<br>-<code>git config --global</code> 옵션을 주었을 때 사용되는 파일<ul>
<li>홈디렉터리에 위치한 것으로 볼 수 있듯이 해당 시스템 사용자에게 적용</li>
</ul>
</li>
<li>./.git/config<ul>
<li>각 git repository에 위치한 설정 파일</li>
<li>repository 별 설정을 저장한다.</li>
</ul>
</li>
</ul>
<p>git의 설정은 IIS의 web.config 처럼 system -&gt; global -&gt; repository 순으로 상속된다.</p>
<h5 id="사용자-설정"><a href="#사용자-설정" class="headerlink" title="사용자 설정"></a>사용자 설정</h5><p>처음 설정이니 사용자 정보를 설정하여 보자. Linux나OS X는 terminal을 실행하고, Windows라면 git bash를 실행한다.</p>
<blockquote>
<p>$ git config –global user.name “Hojin, Jun”<br>$ git config –global user.email “crynut84@gmail.com”</p>
</blockquote>
<p>사용자명과 이메일을 설정하였다. git은 commit할 때 이 정보를 사용한다. <code>--global</code> 옵션에서 알 수 있듯이 시스템의 사용자에게 적용되는 옵션이다. <code>--global</code> 옵션을 빼고 각 repository 별로 설정 할 수 도 있다.</p>
<p><code>git config --list</code>로 모든 설정을 확일 할 수있고. <code>git config user.name</code>처럼 특정 설정을 확인 할 수도 있다.</p>
<h3 id="git-init-git-clone"><a href="#git-init-git-clone" class="headerlink" title="git init, git clone"></a>git init, git clone</h3><p>git repository를 만드는데는 2가지 방법이있다. 하나는 내 로컬의 디렉터리를 git repository로 만드는 것이고 원하는 디렉터리에서 아래 명령을 실행하기만 하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>이 명령을 실행하면 <strong>.git</strong> 이라는 디렉터리가 만들어지는데 이안에 있는 내용이 git이 repository를 관리하기 위한 파일이고 이후의 저장소 내부의 변화를 감지하기 시작한다. 그리고 <code>git init</code> 명령을 실행한 디렉터리를 <strong>working directory</strong>라고 부른다.</p>
<p>다른 하나는 이미 만들어져 있는 git repository를 <code>clone</code>하는 것이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
<p>clone 명령어를 이용해 가져 올 수 있는데 url은 repository의 주소이다. <a href="https://github.com" target="_blank" rel="noopener">github</a>를 기준으로 다음과 같이 clone 할 수 있는 url을 제공해 준다.<br><img src="http://crynut84.github.io/images/posts/basic-command-git/github-clone-url.jpg" alt="github clone url"></p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 명령으로 현재 repository의 현재 상태를 확인 할 수 있다. <code>git init</code> 명령어로 생성한 repository의 상태를 확인해보자.<br>!(git init)[<a href="https://crynut84.github.io/images/posts/basic-command-git/git-init.jpg">https://crynut84.github.io/images/posts/basic-command-git/git-init.jpg</a>]<br>branch가 master(git의 기본 branch명)인 것과 commit이 없으니 파일을 생성/복사한 후 <code>git add</code> 명령으로 트래킹하라는 메세지를 볼 수 있다.</p>
<p>a.txt라는 빈 텍스트 파일을 생성한 후 <code>git status</code> 명령어로 확인 해보면 아래와 같이 <strong>Untracked files</strong> 목록에 a.txt 파일을 볼 수 있다.<br><img src="https://crynut84.github.io/images/posts/basic-command-git/git-status-after-add-file.jpg" alt="git status after add file"><br>이 상태를 이해하기 위해서는 먼저 git의 working directory에 있는 파일의 라이프사이클에 대해 알 필요가 있다.<br><img src="https://crynut84.github.io/images/posts/basic-command-git/lifecycle.jpg" alt="git file life cycle"></p>
<p>위의 그림에서 알 수 있듯이 파일은 관리되는 파일(Tracked)과 관리되지 않는 파일(Untracked)로 나뉜다.</p>
<ul>
<li>Tracked<br>파일의 상태를 감시한다. 파일의 상태를 아래 3가지로 분류하여 관리한다.</li>
<li>Unmodified<br>파일의 변경이 없는 상태</li>
<li>Modified<br>파일이 수정된 상태</li>
<li>Staged<br>Modified 상태의 파일을 commit 하려면 Stated 상태로 만들어야한다.</li>
<li>Untracked<br>파일의 상태를 감시하지 않는다.</li>
</ul>
<p>이제 앞서 추가한 a.txt 파일이 <strong>Untracked</strong> 상태인것이 이해 될 것이다. 우리가 처음으로 파일을 추가하면 Untracked 상태로 추가된다.</p>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>그럼 a.txt파일을 <code>git add</code> 명령어로 추가해보자. git add [파일명]으로 추가 할 수 있다.</p>
<blockquote>
<p>$ git add a.txt</p>
</blockquote>
<p><img src="https://crynut84.github.io/images/posts/basic-command-git/git-stated-file.jpg" alt="git stated file status"><br>이렇게 Untracked 상태인 파일을 add하면 Stated 상태가 된다. 앞서 설명했듯이 Staged 상태의 파일은 commit에 포함되는 대상이 된다.</p>
<p>아직 배우지 않았지만 <code>git commit</code> 명령어를 이용하여 commit을 해보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'first commit'</span></span><br><span class="line">[master (root-commit) 5488e51] first commit</span><br><span class="line">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 a.txt</span><br></pre></td></tr></table></figure>
<p>1개의 파일(a.txt)가 commit 된것을 확인 할 수 있다. 다시 <code>git status</code>로 상태를 확인해보면 commit 할 것이 없으며 working directory도 클린하다고 알려준다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>이 상태에서 a.txt 파일을 수정해 보자. 수정하면 자연스럽게 modified 상태로 바뀔 것 임을 예상 할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'파일 수정'</span> &gt; a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	**modified:   a.txt**</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>이제 <code>git add</code> 명령을 실행하면 a.txt는 다시 Staged 상태가 되고, commit의 대상이 된다. 즉 <code>git add</code>명령은 <em>Untracked 상태이거나 Modified 상태인 파일을 Staged 상태</em>로 바꾸는 명령어이다.</p>
<p>Staged 상태에 대해 더 자세히 알아보기 위해 `git add’하고 파일을 한번 더 수정해 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'파일을 한번 더 수정'</span> &gt; a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">**Changes to be committed:**</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br><span class="line"></span><br><span class="line">**Changes not staged <span class="keyword">for</span> commit:**</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br></pre></td></tr></table></figure>
<p>a.txt의 상태가 두개가 되었다. 어떻게 된 것일까? 이 개념이 아주 중요한데, <strong>Stated 상태라는 것은 <code>git add</code>할 당시의 파일을 스냅샷</strong>이라는 것이다. 위에 있는 Stated 상태의 a.txt의 내용은 <code>git add</code>를 했을 당시 내용인 ‘파일 수정’이라는 문구가 있을 것이고 UnStated 상태의 a.txt 파일에 내용은 ‘파일을 한번 더 수정’이라는 문구가 들어 있을 것이다. 만약 이 상태로 <code>commit</code>을 수행하면 Staged 상태의 내용인 ‘파일 수정’ 문구가 들어있는 a.txt의 스냅샷이 commit 된다.</p>
<p>마지막으로 수정한 정보까지 포함하여 commit 하고 싶다면 <code>git add</code> 명령으로 한번 더 a.txt를 추가 해 주면 된다.</p>
<p>추가로 일반적으로 프로젝트를 수행하면 여러 파일을 추가/수정 하는 일이 많을 텐데, 그런경우 <code>git add *.js</code> 나 <code>git add .</code> 같이 한번에 여러 파일을 add 하는 방법도 있다.</p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>위의 예에서 보았듯이 Staged 상태라는 것은 <code>git add</code> 할 당시의 파일의 스냅샷이다. 그런데 개발을 하다보면 <code>git add</code>한 파일을 무심코 다시 수정하고 그냥 commit하는 실수가 있을 것 같다.<br><code>git diff</code>명령은 이럴 때 유용한 명령인데, Staging 영역(Stated된 스냅샷을 모아놓은 영역)과 Working Directory의 차이를 보여준다.<br>위의 예제에서 <code>git diff</code> 명령을 수행해 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/a.txt b/a.txt</span><br><span class="line">index ecb3871..40efd75 100644</span><br><span class="line">\--- a/a.txt</span><br><span class="line">+++ b/a.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-파일 수정</span><br><span class="line">+파일을 한번 더 수정</span><br></pre></td></tr></table></figure>
<p>Staging 영역에는 ‘파일 수정’이라는 내용의 파일이 Working 영역에는 ‘파일을 한번 더 수정’이라는 내용의 파일이 들어있는 것을 볼 수 있다.<br>commit을 수행하기 전에는 항상 <code>git status</code>로 내가 포함 할 파일의 목록이 정확히 포함 되었는지 확인 하고 <code>git diff</code> 명령으로 staging 영역과 working 영역의 차이가 없는지 살피는 습관을 들인다면 commit을 실수하는 일을 줄 일 수 있을 것이다.</p>
<p>추가로 Staged 상태와 이전 commit의 상태를 비교해 보려면 <code>git diff --cached</code> 옵션을 붙여서 실행하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/a.txt b/a.txt</span><br><span class="line">index e69de29..ecb3871 100644</span><br><span class="line">\--- a/a.txt</span><br><span class="line">+++ b/a.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+파일 수정</span><br></pre></td></tr></table></figure>
<p>이전 상태의 commit에서 a.txt는 빈파일이었으니 아무것도 나오지 않았고 현재 Stated 상태의 a.txt는 ‘파일 수정’이라는 문구가 추가로 들어갔다는 것을 볼 수 있다.</p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>드디어 git에서 가장 중요한 명령어 중 하나인 <code>git commit</code> 명령어를 소개 할 차례이다. commit은 하나의 작업단위(변경사항)를 local repository에 기록하는 것이다.</p>
<p>그럼 하나의 commit은 언제 만드는 것이 좋을까? 프로젝트를 수행함에 있어, 코드를 변경한다는 것은 어떠한 목적(요구사항)을 달성하기 위한 행위이다. 나는 이슈관리시스템(TFS)에서 하나의 Backlog item이나 Bug item을 할당 받으면 그것을 분석하여, 논리적으로 묶일 수 있는(혹은 다른 코드에 영향이 없을단위)로 쪼개서 하위 Task를 생성한다. 그리고 이 Task를 commit과 1:1로 맵핑 시킬 수 있도록 노력하는 편이다. 그렇기에 어떤 commit에는 100개의 파일이 추가/수정/삭제되어 있을 수도 있고, 어떤 commit에는 단하나의 파일만 수정되어 있을수도 있다. commit의 단위는 자유롭게 설정하여 사용 할 수 있기 때문에 어떻게 제한 할 지는 각 프로젝트의 상황이나 팀원간의 합의에 따라 적절하게 정하면 된다.<br>다만 commit을 작성하는데 참고가 될만한 글을 소개한다.<br><a href="http://haruair.com/blog/2683" target="_blank" rel="noopener">커밋 메시지에 대해</a>라는 제목의 글인데 커밋메세지를 작성하는 방법에대해 토론한 내용을 정리한 글이다.</p>
<blockquote>
<p>변경 사항에 따라 로직을 이해할 수 있는 수준의 단일 커밋 단위로 쪼개야 한다.</p>
</blockquote>
<p>커밋 메세지를 작성하는 방법에서 커밋의 단위를 어떻게 가져가야 할지 예측해 볼 수 있을 것이다.</p>
<p>위의 예제를 계속 이어가기 위해 a.txt를 stating 영역으로 add하고 git status로 변경 사항을 확인한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br></pre></td></tr></table></figure>
<p>이 상태에서 <code>git commit&#39; 명령을 수행하면 commit 메세지를 적을 수 있는 text-editor가 실행된다.
!(github clone url)[https://crynut84.github.io/images/posts/basic-command-git/git-commit-editor.png]
이 editor는</code>git config –global core.editor<code>명령으로 변경 가능하다. editor를 실행하면 여러줄의 commit 메세지를 작성 할 수 있고, 한줄의 짧은 메세지로 commit 할 경우에는 위의 예제에서 실행 했듯이</code>-m’ 옵션을 주어 짧은 commit을 실행 할 수도 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'my commit message'</span></span><br><span class="line">[master ac05efa] my commit message</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>모든 변경사항을 commit한 후 <code>git status</code>명령으로 상태를 확인하면 위와같이 working directory가 깨끗하다는 메세지를 확인 할 수 있다. 모든 변경사항이 commit 된 것이다. 한번 commit한 사항은 local repository에 저장되기에 언제든 조회,복구 할 수 있다. 특별한 일이 없는 한 commit된 것은 날아가지 않는다.(remote server에 push한 경우에는 더더욱) 하지만 commit 하지 않은 것은 언제든 잃어 버릴 수 있다.</p>
<p>또한 위의 링크에서도 알 수 있듯이 우리는 commit 메세지 작성을 잘 해야한다. commit 메세지가 잘 작성된 경우에는 commit 메세지를 확인 하는 것만으로도 프로젝트의 히스토리를 파악 할 수 있다.</p>
<p>추가로 <code>git add</code>하지 않은 Working영역의 Tracked file을 모두 커밋하고자 할때에는 <code>-a</code>옵션을 사용한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">'commit all tracked files'</span></span><br></pre></td></tr></table></figure>
<p><code>-a</code> 옵션을 사용경우 git은 Working영역의 파일을 stating 영역에 넣고, commit하는 것과 동일한 결과를 준다.</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>프로젝트 파일을 수정 할 때 어떠한 목적을 가지고(하나의 commit에 묶일 수 있도록) 파일을 수정하겠지만, 사람이 하는 일이 항상 마음 먹은대로되는 것은 아니다. a.txt파일을 수정하는 미션을 받고 수정하는 중에 b.txt파일을 추가 했다고 가정해 보자. 논리적으로 a.txt파일을 수정한것만 하나의 commit으로 묶어야한다면, a.txt 파일을 <code>git add</code>하여 Stating 영역에 넣고 commit 하면 된다. 그런데 실수로 b.txt파일도 Stating 영역에 들어갔다면 b.txt파일을 다시 working 영역으로 옮기는 방법이 필요하다.</p>
<p>이럴 때 ‘git reset’명령을 사용하면 된다. 실습을 위해 a.txt파일을 수정하고, b.txt파일을 새로 만들어 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'modify a.txt file'</span> &gt; a.txt</span><br><span class="line">$ cat &gt; b.txt</span><br><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br><span class="line">	new file:   b.txt</span><br></pre></td></tr></table></figure>
<p><code>git add *</code> 명령으로 모든 변경사항이 stating 영역에 포함되었다. 이 상태에서 commit하면 a.txt,b.txt두개의 파일이 commit 될 것이다. b.txt를 commit에서 제외하기 위해 아래와 같이 <code>git reset</code> 명령어를 수행해 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD b.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	b.txt</span><br></pre></td></tr></table></figure>
<p>b.txt파일이 이전 상태로 돌아간 것을 확인 할 수 있다. 이처럼 <code>git reset</code>은  staging 영역에서 working 영역으로 되돌리는 역할을하고, 이를 이용해 commit이 포함될 파일을 조절 할 수 있다.</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>git이 관리하는(Tracked) 파일을 삭제하려면 어떻게 해야할까? 윈도우의 탐색기나 OSX의 Finder에서 파일을 삭제하거나 Terminal에서 RM 명령을 통해 삭제하면 된다.</p>
<p>위의 예제에서 working directory를 clean한 상태로 만들고 이어서 실습해 보자.(clean하게 하려면 commit 하면 된다.)<br>a.txt파일만 있는 상황에서 terminal에서 rm 명령을 이용해 파일을 삭제한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rm a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    a.txt</span><br></pre></td></tr></table></figure>
<p>git은 파일의 삭제도 훌륭하게 추적하여 파일이 삭제되었음을 알려준다. 이 상태에서 <code>git add</code>명령어로 staging 영역에 추가하고 <code>git commit</code>하면 파일이 삭제된 스냅샷이 git repository에 저장 될 것이다.(앞서 배웠듯이 <code>git -a commit</code>명령으로 한번에 add+commit 할 수도 있다.)</p>
<p>git에서도 <code>git rm</code>이라는 명령어를 제공한다. 그냥 삭제해도 git이 알아서 인식하는데 왜 별도의 명령을 제공하는 것일까? 그냥 파일을 삭제해도 되지만 명령어는 몇가지 기능이 더 있다.<br>기본적으로 <code>git rm</code> 명령을 통해 파일을 삭제하면 파일을 삭제하고 자동으로 staging 영역으로 넣어준다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rm a.txt</span><br><span class="line">rm <span class="string">'a.txt'</span></span><br><span class="line">$ ls -l</span><br><span class="line">total 0</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	deleted:    a.txt</span><br></pre></td></tr></table></figure>
<p>그리고 이미 staging 영역으로 들어간 파일을 물리적으로 삭제하면 다음과 같이 2개의 상태를 가지게 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	deleted:    a.txt</span><br><span class="line">   new file:   b.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    b.txt</span><br></pre></td></tr></table></figure>
<p>b.txt가 새로 생성되었고, 삭제된 상태이다. git은 실수로 삭제하는 것을 막기위해서 이런 방법을 사용한다. <code>git rm -f</code> 옵션을 사용하면 바로 삭제처리도 가능하다.</p>
<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p><code>git mv</code>명령은 파일을 이동하는 명령이다. 이동이라는 것은 경로를 바꾼다는 뜻이며, 파일의 이름을 변경하는 행위와도 같다. 사용법도 아주 쉽다. 아래를 참조하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git mv a.txt c.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	renamed:    a.txt -&gt; c.txt</span><br></pre></td></tr></table></figure>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>TFS를 사용할 때 Shelve(보류)라는 기능을 유용하게 사용했었다. 이런 시나리오는 생각해보자. 어떤 Task를 할당받아 열심히 개발하는 중에 치명적인 버그가 발견되었다. 급하게 Hot Patch를 내놓아야 하는 상황에서 선택 할 수 있는 방법은 두가지이다.</p>
<p>하나는 현재 개발 중인 Task를 최대한 빨리 마무리하고, Hot Patch를 개발하는 방법이고, 또하나는 현재 진행하던 Task를 버리고(되돌리고) 급한 패치부터 개발하는 방법이다. Shelve는 이럴때 유용하게 사용 할 수 있는데 진행하던 Task를 보류시켜 놓고(어딘가에 저장) 이전 상태로 돌아가 Hot Patch를 만들어 checkin한 후 다시 보류된 작업을 꺼내와서 Task를 이어서 진행하는 방법이다.</p>
<p>git에도 <code>git stash</code> 명령어를 통해서 위와같은 시나리오에 대응 할 수 있다. 파일을 변경한 상태에서 (즉 워킹 디렉토리가 clean하지 않은 상태) <code>git stash</code> 명령을 사용하고 <code>git staus</code>명령으로 상태를 확인하면 아래와 같이 clean 한 상태가 된다. 이때 위의 시나리오처럼 다른 작업을 할 수 있는 것이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'change c.txt'</span> &gt; c.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   c.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">rynut84@ubuntu:~/work/git-test git stash</span><br><span class="line">Saved working directory and index state WIP on master: da3fe70 rename a.txt -&gt; c.txt</span><br><span class="line">HEAD is now at da3fe70 rename a.txt -&gt; c.txt</span><br><span class="line">crynut84@ubuntu:~/work/git-test$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>또한 stash 된 목록을 <code>git stash list</code> 명령으로 확인 할 수 있고, stashing 한 목록을 복원하려면, `git stash pop’ 명령을 이용하면 된다.</p>
<p>총 11가지 명령으로 git의 local repository를 다루는 방법을 배웠다. git이 가진 명령어는 지금 소개한것보다 훨씬 많지만(옵션까지 하면 더 많다) 이정도만 알아도 크게 불편한 점이 없었고, 더 자세한 기능은 그때그때 찾아보면서 쓰는 편이다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/19/basic-command-git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/16/install-git/">
                            git 간단 개념과 설치 방법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-16T08:46:53+09:00">
	
		    2015-06-16
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>이전 포스팅에서 <a href="https://crynut84.github.io/2015-06-10/introduction-to-git.html">분산 버전 관리 시스템의 개념</a>을 살펴보았으니, 대표적인  분산 버전 관리 시스템인 git에 대해 알아보려 한다.</p>
<p>git <a href="http://git-scm.com" target="_blank" rel="noopener">공식 사이트</a> 메인페이지에 보면 git을 아래와 같이 소개한다.</p>
<blockquote>
<p><strong><em>Git is easy to learn</em></strong> and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.</p>
</blockquote>
<p>배우기 쉽다는 것인데, 내가 처음 git을 배울 때는 다음과 같은 이유로 git이 무지 어려웠다.</p>
<ul>
<li>.NET을 주 언어로 사용하는 개발자로 윈도우의 GUI 환경에 익숙하다.<ul>
<li>git GUI 환경이 있기는 하지만 결국 CLI을 알아야 한다.</li>
</ul>
</li>
<li>기존에 사용하던 버전 관리 시스템(TFS, SVN등)의 개념으로 이해하려 했다.<ul>
<li>git을 배우려면 기존의 생각을 버리는게 더 빠르다.</li>
</ul>
</li>
<li>git과 <a href="https://github.com/" target="_blank" rel="noopener">github</a>의 개념을 혼동.<ul>
<li>github는 git 기반의 온라인 소스 관리 서비스이다.</li>
<li>많은 자료에서 git과 github를 함께 설명하다 보니 해깔렸다.</li>
</ul>
</li>
</ul>
<p>그래서 나는 순수(?) git을 기능을 먼저 알아보려고 한다.</p>
<h2 id="git-소개"><a href="#git-소개" class="headerlink" title="git 소개"></a>git 소개</h2><p>git은 <a href="http://git-scm.com" target="_blank" rel="noopener">공식 사이트</a>에 document가 굉장히 잘 만들어져 있다. 요즘 오픈소스는 대부분 document에 공을 들이는 것 같다. 고마운 분들이 번역해 놓은 <a href="http://git-scm.com/book/ko/v2" target="_blank" rel="noopener">한글판</a>도 있다. 덕분에 특별히 책을 구입하지 않아도 배울 수 있다.</p>
<p><a href="http://git-scm.com/about" target="_blank" rel="noopener">About 페이지</a>에가보면 다음의 6가지 주제로 git을 소개하고 있다. 이 개념들이 기존 버전관리 시스템과 다른점이고 git을 사용하면서 얻을 수 있는 이점이다.</p>
<ul>
<li>Branching and Merging</li>
<li>Small and Fast</li>
<li>Distributed</li>
<li>Data Assurance</li>
<li>Staging Area</li>
<li>Free and Open Source</li>
</ul>
<h3 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h3><p>git은 branch를 만드는데 부담이 없다. 그렇기 때문에 작은 단위의 기능으로 새 branch를 만들고 거기에 원하는 기능을 개발하거나, 실험하고 싶었던 기능을 실험 할 수 있다.  실험에 실패한다면? 그냥 branch를 버리는것으로 끝난다. 아무런 사이드 이펙트가 없다. 나는 TFS를 이용할 때 Branch를 만들때마다 부담스러웠다. 만드는 속도, 용량등 자주 만들기에는 너무 큰 부담이었고(덕분에 회사에 품의를 올려 256G SSD를 추가 구매 할 수 있었지만..) git을 사용하면 이런 고민을 조금은 덜 수 있다.</p>
<p>git은 branch를 만들어 구현하고, 구현한것을 commit 하고, 때때로 원래 branch로 돌아가 심각한 버그에대한 hotpatch를 만들 수 있다.</p>
<h3 id="Small-and-Fast"><a href="#Small-and-Fast" class="headerlink" title="Small and Fast"></a>Small and Fast</h3><p>branch를 만들고 merge하는 것이 부담스럽다면, 위와같은 작업을 할 수 없을 것이다. git은 거의 모든 작업을 local repository에서 수행하기 때문에 속도가 빠르다. 심지어 branch를 만들때도 remote server가 없어도 된다. 나중에 설명 하겠지만 git의 branch는 commit을 가르키는 포인터일 뿐이고, 그렇기 때문에 branch를 만드는 것 또한 빠르고 작은 용량으로 가능하다.</p>
<h3 id="Distributed"><a href="#Distributed" class="headerlink" title="Distributed"></a>Distributed</h3><p>분산 저장소는, 모든 사용자들이 온전한 git repository를 가진다는 의미이다. 내가 진행중인 프로젝트를 git을 이용하여 내려받는다면, 나는 remote repository와 동일한 repository를 내 local에 가져오게 된다. 이말을 바꿔말하면 단지 repository를 가져오는 것만으로 source, commit hitsotry등 모든 요소를 가져오게 된다는 말인다. 최악의 경우 remote server의 장애로 모든 데이터를 날렸다고 하더라도, 다른 사용자의 repository를 이용해 복원 할 수 있다는 말인다.</p>
<p>그리고, 개발자들은 각자의 repository에서 작업하고(네트워크 없이) 작업이 끝난경우 remote repository로 push하여 개발 할 수 있고, git을 활용하여 업무의 workflow를 유연하게 적용 할 수 있다.<br><img src="https://git-scm.com/images/about/workflow-b@2x.png" alt="Integration Manager Workflow"><br>출처 : <a href="https://git-scm.com/images/about/workflow-b@2x.png" target="_blank" rel="noopener">https://git-scm.com/images/about/workflow-b@2x.png</a></p>
<h3 id="Data-Assurance"><a href="#Data-Assurance" class="headerlink" title="Data Assurance"></a>Data Assurance</h3><p>git은 관리하는 모든 파일을 암호화하여 보관하고, 체크썸을 이용하여 파일의 유효성을 보장한다. 그리고 각 commit에는 commit 아이디가 부여되여 관리 되기 때문에 hitory 관리에도 유용하게 적용 할 수 있다.</p>
<h3 id="Staging-Area"><a href="#Staging-Area" class="headerlink" title="Staging Area"></a>Staging Area</h3><p>처음 git을 접하면 어렵게 느껴지는 부분인데 git에는 다른 VCS에는 없는 <code>staging area</code>가 있다.(index라고도 부름)<br><img src="https://git-scm.com/images/about/index1@2x.png" alt="Git staging area"><br>출처 : <a href="https://git-scm.com/images/about/index1@2x.png" target="_blank" rel="noopener">https://git-scm.com/images/about/index1@2x.png</a></p>
<p>파일들은 working directory에 있다. 이 상태에서 a.txt파일을 수정하면 파일의 상태가 modified로 바뀌고, 예상하는 바와같이 commit을 하면 a.txt가 commit 될 것처럼 보인다. 하지만 git에서는 이렇게 동작하지 않는다. modiried 상태인 a.txt파일을 staging area로 등록해야만 commit에 포함된다. 즉 git은 stating area의 스냅샷을 commit으로 기록하는 것이다.</p>
<h3 id="Free-and-Open-Source"><a href="#Free-and-Open-Source" class="headerlink" title="Free and Open Source"></a>Free and Open Source</h3><p>git은 <a href="http://opensource.org/licenses/GPL-2.0" target="_blank" rel="noopener">GNU General Public License version 2.0</a> 라이선스 정책을 따르고 있으며, 모든 사용자에게 무료로 제공된다. 주의할 점은 git의 <a href="http://git-scm.com/downloads/logos" target="_blank" rel="noopener">로고</a>는 다른 <a href="http://git-scm.com/trademark" target="_blank" rel="noopener">라이선스 정책</a>을 따른다는 것이다.</p>
<h2 id="git-설치"><a href="#git-설치" class="headerlink" title="git 설치"></a>git 설치</h2><p>git을 설치하는데는 큰 어려움이 없다. Linux와 Mac OS X, Windows의 버전이 조금씩 다른데, <a href="http://git-scm.com/downloads" target="_blank" rel="noopener">Downloads</a> 페이지에서 각 OS별 download를 제공한다.</p>
<h3 id="Windows에-설치"><a href="#Windows에-설치" class="headerlink" title="Windows에 설치"></a>Windows에 설치</h3><p>Windows의 경우 download 페이지에 가면 설치파일이 제공된다. 다운로드받아 설치하는것으로 쉽게 가능하다. 설치 후 git bash를 이용하여 사용하면 된다.</p>
<h3 id="Linux에-설치"><a href="#Linux에-설치" class="headerlink" title="Linux에 설치"></a>Linux에 설치</h3><p>Ubuntu의 경우 apt-get(pakage manager)를 이용하여 쉽게 설치할 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git</span><br></pre></td></tr></table></figure></p>
<h3 id="Mac에-설치"><a href="#Mac에-설치" class="headerlink" title="Mac에 설치"></a>Mac에 설치</h3><p>Mac의 경우에도 download 페이지에서 installer를 제공하기 때문에 손쉽게 설치 가능하다.</p>
<p>어떤 OS든 git 설치가 되었는지 확인하려면 git의 버전을 보는 명령어를 실행하여 현재 git의 버전을 확인할 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure></p>
<p><img src="https://crynut84.github.io/images/posts/install-git/git-version.png" alt="git version"></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/16/install-git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/10/introduction-to-git/">
                            분산 버전 관리 시스템 git 소개
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-10T08:40:44+09:00">
	
		    2015-06-10
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>2010년 대학교 졸업 후 취업 할 생각은 안하고 빈둥거리고 있을 때, 지인의 소개로 모 회사의 SI 프로젝트에 프리랜서 자격으로 참여 할 수 있었다. </p>
<p>프리랜서이지만 나름 첫 출근날, 상콤한 마음으로 프로젝트 장소에 도착하여 간략하게 개발업무에 대한 설명을 듣고, 개발환경을 구축하려는 그때부터 나는 멘붕에 빠져버렸다.</p>
<p>사실 대학교 막 졸업한 내가 제대로 할 줄 아는것이 무었이 있었겠는가? 그냥 다 할 줄 안다고 패기있게 참여한 프로젝트였지만 첫 시작부터 예상치 못한 친구인 “버전 관리 시스템”을 만나게 되었다. 당시 그 업체에서는 <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_SourceSafe" target="_blank" rel="noopener">Visual Source Safe</a>라는 툴을 사용하고 있었는데, 버전 관리 시스템이라것을 거기서 처음 들은 나는 Source Safe에서 소스 받아가라는 PL의 말을 알아듣지 못 할 수 밖에..</p>
<p>대학에서 친구 몇 명과 조그만 프로젝트를 개발 할 때는 한명이 프로젝트를 생성하여 큰 틀을 만들고, 각자 역할에 나누어 개발 후 한 사람 PC에 옹기종기 모여 각자 개발 한 모듈을 USB에 담아 취합하는 작업을 했었다. </p>
<p>시스템이 복잡하면 할 수록 점점 소스를 취합하는것이 힘들어 질 것이다. 그리고 특정 파일을 3일전의 상태로 돌리고 싶다면 어떨까? 매일매일 소스를 백업하여 아래같이 해둔다면 어찌 해 볼 수 있겠지만 그마저도 없다면 오롯이 내 머릿속의 기억에만 의존해야하는 최악의 사태가 벌어 질 수 있다.  </p>
<ul>
<li>2015-06-01.zip  </li>
<li>2015-06-02.zip  </li>
<li>2015-06-03.zip   </li>
</ul>
<p>어떻게 이런 문제들을 해결 할 수 있을까?</p>
<h2 id="버전-관리-Version-Control-란"><a href="#버전-관리-Version-Control-란" class="headerlink" title="버전 관리(Version Control)란?"></a>버전 관리(Version Control)란?</h2><p>개발자들은 자신의 머리가 그리 똑똑하지 못하는다는것을 오래전에 깨닫고 파일의 변화를 기록하는 시스템을 만들었으니 그게 버전관리 시스템이다.</p>
<p>아마 처음에는 자신의 컴퓨터에 있는 파일의 버전을 관리해주는 프로그램을 개발 했을 것이다.<br>내가 짠 소스코드의 변화를 시스템이 관리해주니 오늘 수정한 소스가 잘못된 것을 알았을 때 손쉽게 그 이전 버전이나, 특정 날짜에 작성한 버전으로 돌릴 수 있었을 것이다. </p>
<p>하지만, 소프트웨어는 여럿이 개발하는 경우가 많으므로, 내가 작성한 코드가 다른 사람에게도 보였으면 하는 생각이 들었을 것이고, 내 로컬에 변경사항을 기록하는 것이 아닌, 소스를 관리하는 서버에 변경사항을 기록하고, 각자 서버에서 소스를 받아서 사용할 수 있는 시스템을 만들었다. 그게 현재 사용하는 TFS, Source Safe, SVN, Subversion과 같은 프로그램이고 이것을 중앙 집중형 버전관리 시스템이라고 한다.</p>
<p>이 프로그램을 사용하면 다음과 같은 장점을 누릴 수 있다.      </p>
<ul>
<li>여러명의 개발자가 하나의 프로젝트를 동시에 개발 할 수 있다.</li>
<li>USB등으로 파일을 copy할 필요 없이 다른 사람이 개발한 소스코드를 내 컴퓨터에 받아 올 수 있다.</li>
<li>이 파일을 누가 언제 어떻게 수정했는지 이력을 볼 수 있다.</li>
<li>문제가 생겨 이전 버전으로 돌아가야하는 일이 생겼을 때 손쉽게 돌아 갈 수 있다.</li>
<li>Branch를 이용하여, 좀 더 안전하게 새 기능을 추가하고 Merge하여 통합 할 수 있다.</li>
<li>내가 A 기능을 개발하는 중에 급하게 Patch해야 할 버그가 생겼을 때도 잠시 A기능을 개발하지 전 상태로 돌려 버그를 수정하고, 다시 A기능을 개발하던 상태로 돌아 갈 수 있다. </li>
</ul>
<p>이렇게 많은 기능을 제공하니, 개발자들은 좀 더 편리하게 개발 할 수 있게 된 것이다. </p>
<p><img src="https://crynut84.github.io/images/posts/introduction-to-git/centralized-version-control.png" alt="중앙집중형 버전관리 시스템"><br>출처 : <a href="https://homes.cs.washington.edu/~mernst/advice/version-control.html" target="_blank" rel="noopener">https://homes.cs.washington.edu/~mernst/advice/version-control.html</a></p>
<p>나는 그동안 <a href="https://msdn.microsoft.com/ko-kr/vstudio/ff637362.aspx" target="_blank" rel="noopener">TFS(Team Foundation Server)</a>를 이용하여 버전관리를 했는데 IDE인 Visual Studio와의 통합도 훌륭하기 때문에 큰 불편함 없이 사용해왔다. </p>
<p>하지만 TFS(중앙 집중형 버전관리 시스템)의 경우 모든 소스를 서버가 관리하기 때문에 다음과 같은 단점이 존재한다.</p>
<ul>
<li>네트워크에 연결되어 있어야만 작업이 가능하다.(소스파일의 checkin, checkout시 서버에 접솝해야 한다.)   </li>
<li>서버에 문제가 생기면 작업을 할 수 없다.   </li>
<li>서버와의 통신이 지속적으로 이루어지기 때문에 네트워크가 느린경우 작업에도 영향을 미친다.   </li>
<li>Branch하면 전체 소스를 다른 폴더에 받아오기 때문에 Branch가 많이 부담스러운 작업이다.</li>
</ul>
<p>분산 버전 관리 시스템을 사용하면 앞서 말한 문제점을 해결 할 수 있다.</p>
<h2 id="분산-버전-관리-시스템"><a href="#분산-버전-관리-시스템" class="headerlink" title="분산 버전 관리 시스템"></a>분산 버전 관리 시스템</h2><p>중앙집중형 버전관리 시스템의 저장소(repository)가 server에만 있는것과 달리 분산 버전 관리 시스템에서 저장소는 모든 client가 저장소가 될 수 있다. 이게 무슨 말일까?</p>
<p>예를들어 TFS에서 get latest version을 통해 저장소에서 project를 가져온가고 생각해 보자. 그럼 저장소에서 사용자의 컴퓨터에 최신의 코드를 받아오게 된다. 분산 버전 관리 시스템의 경우 어떻까? server에서 저장소자체를 통채로 받아오게 된다. 이 말은 소스코드는 물론 그동안의 변경 이력까지 모든 정보를 가져와 로컬 컴퓨터 또한 완전한 저장소가 된다는 뜻이다.</p>
<p>이렇게 됨으로써 한번 저장소를 받아온 이후에 개발작업에서는 서버와는 별개로 자신의 로컬에서 진행하게 되고, 로컬이니 당연히 빠른 속도로 변경 할 수 있는 것이다. 만약 main.cs 파일의 지난 히스토리와 diff 하고 싶을 경우 TFS는 서버와의 통신을 통해 diff하는 반면 분산 버전 관리 시스템은 로컬에 있는 저장소에서 변경 이력을 찾아 diff해 준다.</p>
<p>이런 분산 버전 관리 시스템의 개념을 구현한 것이 git, Mercurial등이 있고, 나는 이제는 대새(?)로 자리잡은 git에 대해 설명 하려고한다. git은 리누즈 토발즈가 리눅스 커널의 버전관리를 위해 만들었다고 알려져 있다. </p>
<h2 id="왜-git으로-바꿔야하나"><a href="#왜-git으로-바꿔야하나" class="headerlink" title="왜 git으로 바꿔야하나?"></a>왜 git으로 바꿔야하나?</h2><p>git은 어렵다. git을 만든 리누즈 토발즈도 한 <a href="http://www.looah.com/article/view/1692" target="_blank" rel="noopener">인터뷰</a>에서 <code>이렇게 쓰기 어려운걸 누가 쓰리라곤 생각도 못했다.</code>고 말했라고 한다. 특히나 CLI보다 GUI가 익숙한 닷넷 개발자는(닷넷개발자가 다 그렇다는 것이 아니다) 인터넷에 있는 git에 대한 사용법을 담은 자료를 보고, <code>버전 관리하는데 머가 이렇게 어려워?</code>라는 생각을 가질 만하다.</p>
<p>우리 <a href="https://www.yooniqimages.com" target="_blank" rel="noopener">회사</a>에서는 올해 초부터 시작해서 6개월동안 git을 사용하기 시작했는데, 내가 생각하는 장점은 다음과 같다.</p>
<ul>
<li>저장소 서버가 느려서 스트레스 받는 일이 줄었다.(우리는 <a href="https://www.visualstudio.com/en-us/products/what-is-visual-studio-online-vs.aspx" target="_blank" rel="noopener">Visual Studio Online</a> 서비스를 이용하고 있는데 서버가 미국에 있다.) </li>
<li>Branch를 마음껏 할 수 있어, Backlog나 Bug 단위로 Branch를 만들어 개발하고 프로덕트를 release하는 Branch(master)는 clean하게 유지할 수 있다.(git workflow) -&gt; 나는 이것이 git을 사용하는 가장 큰 benefit이라고 생각한다. </li>
</ul>
<p>이 외에도 만약 이런 상태라면 git을 쓰자.</p>
<ul>
<li>버전관리 시스템을 써본적이 없다. 하지만 이제부터 쓸 예정이다.</li>
<li>github 서비스를 remote 저장소로 사용 할 예정이다.</li>
<li>머릿속에 프로젝트에 대한 새로운 아이디어가 넘치는데 중앙의 source 이력을 망가뜨리지 않고 마구 실험해 보고 싶다. </li>
<li>오픈소스의 컨트리뷰터가 되고 싶을 때(많은 오픈소스가 git으로 진행되거나 전환하고 있다)</li>
<li>git이 대세라는데 그 이유가 궁금하다.(써보면 안다)</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/10/introduction-to-git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Hojin Jun. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=110" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Hojin Jun</h4>
        
            <div id="about-card-bio"></div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>programmer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
