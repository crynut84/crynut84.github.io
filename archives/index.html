
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="전호진 블로그">
    <title>Archives - 전호진 블로그</title>
    <meta name="author" content="Hojin Jun">
    
    
        <link rel="icon" href="https://crynut84.github.io/assets/images/favicon.ico">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="개발하다 마주치는 사소한 일들..">
<meta property="og:type" content="blog">
<meta property="og:title" content="전호진 블로그">
<meta property="og:url" content="https://crynut84.github.io/archives/index.html">
<meta property="og:site_name" content="전호진 블로그">
<meta property="og:description" content="개발하다 마주치는 사소한 일들..">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="전호진 블로그">
<meta name="twitter:description" content="개발하다 마주치는 사소한 일들..">
<meta name="twitter:creator" content="@crynut84">
    
    
        
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=640"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-63739974-1', 'auto');
        ga('send', 'pageview');
    </script>


        
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">전호진 블로그</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=90" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=110" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Hojin Jun</h4>
                
                    <h5 class="sidebar-profile-bio"></h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/crynut84" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.facebook.com/hojin.jun" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/01/10/building-dev-env-using-wsl/">
                            Windows10에서 Linux 개발환경 구축
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-01-10T07:58:25+09:00">
	
		    2018-01-10
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>2년 정도 OS X를 개발환경으로 사용했더니, 얼마 전 이직한 회사의 Windows 10 환경이 낯설게만 느껴졌다. Shell이 제일 불편했고, 각종 오픈소스 문서에 나오는 설정을 따라 하는데 Windows의 경우 설명이 친절하지 않은 경우가 많았다. </p>
<p>집에서는 Mac을 사용하다 보니 매번 다른 환경이 적응 안되기도 하고 남들 다 윈도우 PC 쓰는데 혼자만 Mac 사달라고 할 수도 없고 <code>git bash</code>로 근근이 버티고 있었는데, Windows 10에 <code>Windows Subsystem for Linux(WSL)</code>라는 반가운 기능이 생긴 걸 알게 되어 그 방법에 관해 설명한다. (아마도 윈도우는 공인인증서 쓸 때만 쓰다 보니 혼자만 몰랐던 듯..)</p>
<h2 id="설치하기"><a href="#설치하기" class="headerlink" title="설치하기"></a>설치하기</h2><h4 id="윈도우-빌드-정보-확인"><a href="#윈도우-빌드-정보-확인" class="headerlink" title="윈도우 빌드 정보 확인"></a>윈도우 빌드 정보 확인</h4><p><code>WSL</code> 기능을 사용하려면 Windows 10의 빌드 버전이 <code>14316</code> 이상이어야 한다. 버전 확인은 [설정] -&gt; [정보] -&gt; [OS 빌드]를 확인하자.<br><img src="https://user-images.githubusercontent.com/5028400/34939095-f3caa526-fa2d-11e7-8e1f-079f7fba37bd.png" alt="image"></p>
<h4 id="개발자-모드-설정"><a href="#개발자-모드-설정" class="headerlink" title="개발자 모드 설정"></a>개발자 모드 설정</h4><p>[설정] -&gt; [업데이트 및 보안] -&gt; [개발자용] -&gt; [개발자 모드] 선택<br><img src="https://user-images.githubusercontent.com/5028400/34939258-8d3473b8-fa2e-11e7-89c0-6af88e2f2eef.png" alt="image"></p>
<h4 id="윈도우-기능-켜기"><a href="#윈도우-기능-켜기" class="headerlink" title="윈도우 기능 켜기"></a>윈도우 기능 켜기</h4><p>[제어판] -&gt; 프로그램 및 기능 -&gt; [Windows 기능 켜기/끄기] -&gt; [Linux용 Windows 하위 시스템] 체크 후 재부팅<br><img src="https://user-images.githubusercontent.com/5028400/34939316-b99c0ea2-fa2e-11e7-8b39-f94a404b8ecc.png" alt="image"></p>
<h4 id="리눅스-설치"><a href="#리눅스-설치" class="headerlink" title="리눅스 설치"></a>리눅스 설치</h4><p><code>cmd</code>를 관리자권한으로 열고 프롬프트에 <code>bash</code>를 치면 아래와 같이 <a href="https://aka.me/webstore" target="_blank" rel="noopener">https://aka.me/webstore</a> 로 가라는 메시지가 나온다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\windows\system32&gt;bash</span><br><span class="line">Linux용 Windows 하위 시스템에 배포가 설치되어 있지 않습니다.</span><br><span class="line">아래의 Windows 스토어에서 배포를 설치할 수 있습니다.</span><br><span class="line">https://aka.ms/wslstore</span><br><span class="line">계속하려면 아무 키나 누르세요...</span><br></pre></td></tr></table></figure>
<p>브라우저에서 위의 주소로 접속하여 Store를 열고 마음에 드는 리눅스 배포판을 선택한다. Utuntu를 선택하여 다운로드해주었다.<br><img src="https://user-images.githubusercontent.com/5028400/34940910-c77e4516-fa34-11e7-9ba6-57a841f56271.png" alt="image"></p>
<p>다운로드가 완료되면 <code>실행</code>을 눌러 설치한다.<br><img src="https://user-images.githubusercontent.com/5028400/34940992-28d8a2d4-fa35-11e7-8549-5d3eef8c6080.png" alt="image"><br>설치가 진행되며 우분투에서 쓸 username과 password를 입력하면 곧바로 <code>bash</code> 셸을 만날 수 있다.</p>
<h4 id="Hyper-설치"><a href="#Hyper-설치" class="headerlink" title="Hyper 설치"></a>Hyper 설치</h4><p>Windows 10의 기본 터미널 프로그램(<code>cmd</code>)은 칙칙한 게 별로다. OS X에서는 <code>iterm</code>을 사용했었는데 Windows 용으로는 나오지 않으니 <a href="https://hyper.is/" target="_blank" rel="noopener">Hyper</a>라는 Web 기반 기술로 만들어진 터미널을 설치하자.</p>
<p>Hyper는 오픈소스 터미널이고 다양한 OS를 지원한다. 그리고 무엇보다 예쁘다. 설치는 간단한데 <a href="https://hyper.is/" target="_blank" rel="noopener">공식 사이트</a>에 들어가서 다운로드하면 되고, 여러 가지 Theme과 plugin을 제공한다.</p>
<p>나는 아래와 같이 몇가지 설정(<code>ctrl + ,</code>)만 바꾸어 사용한다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updateChannel: 'canary',</span><br><span class="line">shell: 'C:\\Windows\\System32\\cmd.exe',</span><br><span class="line">shellArgs: ['--login', '-i', '/c wsl'],</span><br><span class="line">plugins: [</span><br><span class="line">        'hyper-material-theme',</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/5028400/34963214-b92a21f0-fa8a-11e7-9c13-19f6a3023998.png" alt="image"></p>
<h3 id="ZSH와-Oh-my-zsh-설치"><a href="#ZSH와-Oh-my-zsh-설치" class="headerlink" title="ZSH와 Oh my zsh 설치"></a>ZSH와 Oh my zsh 설치</h3><p>bash는 뭔가 밋밋하고, 자동완성도 별로라 linux 초보인 나를 더 힘들게 한다. zsh 셸로 갈아타 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br><span class="line">chsh -s /usr/bin/zsh <span class="comment"># 기본 쉘 변경</span></span><br></pre></td></tr></table></figure>
<p>zsh를 설치했으면 <code>oh my zsh</code>도 설치해서 더 강력한 셸로 만들자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure></p>
<h4 id="테마-설치"><a href="#테마-설치" class="headerlink" title="테마 설치"></a>테마 설치</h4><p>vi로 <code>~/.zshrc</code>를 열어 아래와 같이 테마를 변경한다. 다른 테마를 원하면 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">여기</a>를 참고하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br></pre></td></tr></table></figure></p>
<p><code>source ~/.zshrc</code> 명령으로 적용하면 아래와 같이 글자가 깨지는 것을 볼 수있다. agnoster 테마가 이모티콘을 사용하는데 폰트가 없어서 그런것이니 폰트도 설치하자.<br><img src="https://user-images.githubusercontent.com/5028400/34963948-6900b730-fa8e-11e7-96a8-f8fea4f86a67.png" alt="image"></p>
<p><a href="https://github.com/powerline/fonts/tree/master/DejaVuSansMono" target="_blank" rel="noopener">DejaVu Sans Mono</a>에서 폰트(.ttf)를 내려받고 더블클릭하여 윈도우에 설치하자.</p>
<p>그리고 hyper config(<code>ctrl + ,</code>)을 눌러 폰트를 변경하면 된다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fontFamily: <span class="string">'"DejaVu Sans Mono for Powerline", ...'</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-images.githubusercontent.com/5028400/34964380-a3f4848c-fa90-11e7-9768-bc051f403657.png" alt="image"></p>
<h3 id="Python-개발환경-설치"><a href="#Python-개발환경-설치" class="headerlink" title="Python 개발환경 설치"></a>Python 개발환경 설치</h3><p>WSL에서는 python 버전 관리를 위해 <code>[pyenv](https://github.com/pyenv/pyenv)</code>도 사용할 수 있다. </p>
<h4 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h4><p>먼저 필요한 패키지를 설치한다. (<a href="https://github.com/pyenv/pyenv/wiki/Common-build-problems" target="_blank" rel="noopener">참고</a>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \</span><br><span class="line">libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \</span><br><span class="line">xz-utils tk-dev</span><br></pre></td></tr></table></figure></p>
<p>다음 명령어로 pyenv를 설치한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure></p>
<p>그 후 <code>~/.zshrc</code> 파일을 열어 맨 아래 path를 적어준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="pyenv-virtualenv"><a href="#pyenv-virtualenv" class="headerlink" title="pyenv-virtualenv"></a>pyenv-virtualenv</h4><p>아래 명령으로 설치한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv</span><br></pre></td></tr></table></figure></p>
<p>그 후 <code>~/.zshrc</code> 파일을 열어 맨 아래 다음 구문을 적어준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</span><br></pre></td></tr></table></figure></p>
<p>간단한 사용 방법은 간단하고 편하다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.6.4 <span class="comment"># python 3.6.4 버전 설치</span></span><br><span class="line">pyenv virtualenv 3.6.4 myenv <span class="comment"># 3.6.4 버전을 기반으로 myenv라는 가상환경 생성</span></span><br><span class="line">pyenv shell myenv <span class="comment"># myenv라는 가상환경 activate</span></span><br><span class="line">pyenv versions <span class="comment"># 설치된 python 버전 목록 출력</span></span><br></pre></td></tr></table></figure></p>
<h4 id="autoenv"><a href="#autoenv" class="headerlink" title="autoenv"></a>autoenv</h4><p>autoenv까지 설치하면 유용한데, 특정 프로젝트 디렉터리에 진입하면 자동으로 스크립트를 실행시킬 수 있기 때문이다. 이 기능을 활용해 <code>pyenv shell xxxenv</code>와 같이 특정 python 환경을 자동으로 activate 할 수 있다.</p>
<p>까먹고 activate 안 한 경험 누구나 한 번쯤 있을 것이다.</p>
<p>다음의 명령으로 설치한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/kennethreitz/autoenv.git ~/.autoenv</span><br></pre></td></tr></table></figure></p>
<p>그 후 <code>~/.zshrc</code> 파일을 열어 맨 아래 다음 구문을 적어준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.autoenv/activate.sh</span><br></pre></td></tr></table></figure>
<p>원하는 디렉터리에 <code>.env</code> 파일을 만들고 스크립트를 적어놓으면 그 디렉터리 접근 시 자동으로 스크립트가 실행된다.<br><code>.env</code> 파일은 종종 다른 라이브러리의 환경설정 파일과 이름이 겹친다. 그래서 나는 <code>.autoenv</code>로 이름을 바꾸어 사용하는데 그러려면 <code>~/.zshrc</code> 파일에 추가한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export AUTOENV_ENV_FILENAME=&quot;.autoenv&quot;</span><br></pre></td></tr></table></figure>
<p>위에 추가한 <code>source ~/.autoenv/activate.sh</code> 보다 위에 추가해야 한다.</p>
<p>처음 디렉터리에 접근 시 1번은 확인하는 구문이 나온다. <code>y</code>를 누르면 지정한 스크립트가 실행되는 것을 볼 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog</span><br><span class="line">autoenv:</span><br><span class="line">autoenv: WARNING:</span><br><span class="line">autoenv: This is the first time you are about to source /mnt/d/work/documents/blog/.autoenv:</span><br><span class="line">autoenv:</span><br><span class="line">autoenv:   --- (begin contents) ---------------------------------------</span><br><span class="line">autoenv:     echo &quot;hello&quot;$</span><br><span class="line">autoenv:</span><br><span class="line">autoenv:   --- (end contents) -----------------------------------------</span><br><span class="line">autoenv:</span><br><span class="line">autoenv: Are you sure you want to allow this? (y/N) y</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<h3 id="Node-js-npm"><a href="#Node-js-npm" class="headerlink" title="Node.js npm"></a>Node.js npm</h3><p>역시 apt-get이 있으니 간편하다. 아래 스크립트의 <code>setup_x.x</code> 부분에 설치하고 싶은 버전을 적으면 된다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></p>
<h3 id="docker-설치"><a href="#docker-설치" class="headerlink" title="docker 설치"></a>docker 설치</h3><p>WSL에는 아쉽게도 docker engine을 설치할 수 없는 것 같다.<br>윈도우에 docker engine을 설치하고 WSL에는 client만 설치하여 사용하는 방법을 선택하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sudo sh</span><br></pre></td></tr></table></figure>
<p>설치 후 <code>docker ps</code> 명령을 쳐보면 docker에 연결할 수 없다고 나온다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure></p>
<p>윈도우 docker를 열고 Expose daemon on tcp://localhost:2375 without TLS 옵션을 선택한다.<br><img src="https://user-images.githubusercontent.com/5028400/34965836-84ec3ca6-fa9a-11e7-973c-7ce27389eb87.png" alt="image"></p>
<p>그 후 <code>~/.zshrc</code>에 <code>DOCKER_HOST</code>를 다음과 같이 설정한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=&apos;tcp://0.0.0.0:2375&apos;</span><br></pre></td></tr></table></figure></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/01/10/building-dev-env-using-wsl/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/14/django-static-file/">
                            django-static-file
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-14T09:05:35+09:00">
	
		    2016-11-14
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/django/">django</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>우리가 개발한 프로젝트를 운영 서버로 배포하다 보면 static 파일을 한데 모으는 <code>python manage.py collectstatic</code>이란 명령어를 접하게된다.<br><code>collectstatic</code> 명령어는 Django 프로젝트의 여러 app에서 사용하는 스테틱 파일을 한 곳(경로)으로 모아주는 역할을 한다.(물리적으로 파일을 copy 한다는 뜻이다)</p>
<h2 id="웹-서버와-웹-어플리케이션"><a href="#웹-서버와-웹-어플리케이션" class="headerlink" title="웹 서버와 웹 어플리케이션"></a>웹 서버와 웹 어플리케이션</h2><p>Django를 이용하여 웹 애플리케이션 개발할 때 Django에 내장된 경량의 웹서버를 사용하게 된다. 하지만 <a href="https://docs.djangoproject.com/en/1.10/intro/tutorial01/#the-development-server" target="_blank" rel="noopener">공식문서</a>에도 경고하고 있는것처럼 이것은 실제 웹서버가 아니므로 Production 환경에서는 사용해서는 안 된다.</p>
<blockquote>
<p>don’t use this server in anything resembling a production environment. It’s intended only for use while developing. (We’re in the business of making Web frameworks, not Web servers.)</p>
<p>프로덕션 환경과 유사한 상황에서는 사용하면 안 된다. 오직 개발 중에만 사용해라.(이건 웹 프레임워크를 만들기 위한 것이지 웹서버가 아니다.)</p>
</blockquote>
<p>그렇다! <code>runserver</code>로 사용하는 개발용 서버는 서버가 아니다. 실제 Production 환경에서는 <a href="https://httpd.apache.org/" target="_blank" rel="noopener">Apache</a>나 <a href="http://nginx.org/" target="_blank" rel="noopener">Nginx</a>와 같은 웹서버를 사용해야 한다. 즉 사용자의 요청(Request)이 들어오면 웹서버가 받아서 적절한 처리 후에 웹 애플리케이션에 넘겨주고 웹 애플리케이션은 우리가 작성한 로직에 따라 적절한 처리 후에 웹서버에 돌려주어 사용자에게 응답(Response)하는 것이다.</p>
<p><img src="https://cloud.githubusercontent.com/assets/5028400/20266416/5b31d844-aab9-11e6-90fc-d9cd73047ef7.png" alt="image"></p>
<p>이것을 간단하게 도식화하면 위의 그림과 같은데 웹서버와 웹 애플리케이션 사이에는 WSGI(Web Server Gateway Interface)라는 규약으로 통신하게 된다.</p>
<h2 id="스테틱-파일을-모으는-이유"><a href="#스테틱-파일을-모으는-이유" class="headerlink" title="스테틱 파일을 모으는 이유?"></a>스테틱 파일을 모으는 이유?</h2><p>HTTP 프로토콜을 이용하여 단순히 파일을 응답하는 처리는 웹서버가 잘하는 일이다. 사용자의 요청의 URL을 해석하여 서버 내의 물리적인 위치의 파일을 찾아 HTTP 응답으로 돌려주는 단순한 작업이기 때문이다. 그에 반해 웹 애플리케이션 동적인 데이터를 처리하기 위해 만들어졌다. 예를 들어 로그인한 사용자마다 카트의 내용이 동적으로 변하여 다르게 보인다든가 하는 처리를 말하는 것이다.</p>
<p>CSS, Javascript, image 파일들로 이루어진 static 파일을 웹어플리케이션인 Django가 처리하기에는 너무 비효율적이다. 웹서버에서 웹 애플리케이션으로 요청을 전달하는 데는 WSGI라는 변환과정을 거치며 이것은 자원을 소모하는 일이고, 굳이 웹서버도 할 수 있는 일을 웹 애플리케이션에서 할 필요가 없는 것이다.</p>
<p>그래서 Django에서는 Production에서의 static 파일을 처리하는 기능을 담고있지 않다.</p>
<h2 id="개발할-때-보니까-되던데"><a href="#개발할-때-보니까-되던데" class="headerlink" title="개발할 때 보니까 되던데?"></a>개발할 때 보니까 되던데?</h2><p>Django 개발할 때는 static 파일이 잘 전송되는 것을 볼 수 있다. 이것은 <code>INSTALLED_APPS</code>의 django.contrib.staticfiles이라는 모듈이 담당하고 있으며, 그마저도 settings.py의 <code>DEBUG</code> 속성을 False로 바꾸면 동작하지 않게된다.</p>
<p>이때부터는 static 파일의 처리는 웹서버가 담당하게 되는 것이다. <a href="https://github.com/house142/anchovy/wiki/%EC%9A%B0%EB%B6%84%ED%88%AC%EC%97%90-Apache%EC%99%80-mod_wsg%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-Django-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95#apache-%EC%84%A4%EC%A0%95" target="_blank" rel="noopener">아파치 설정</a> 중에도 static 파일의 경로를 정의하는 설정이 포함되는 것을 알 수 있다.</p>
<h2 id="스테틱관련-설정"><a href="#스테틱관련-설정" class="headerlink" title="스테틱관련 설정"></a>스테틱관련 설정</h2><p>Django <a href="https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-STATIC_ROOT" target="_blank" rel="noopener">공식 문서</a>를 보면 settings.py에 정의 할 수 있는 static 관련 설정이 나온다.</p>
<ul>
<li><code>STATIC_ROOT</code></li>
<li><code>STATIC_URL</code></li>
<li><code>STATICFILES_DIRS</code></li>
</ul>
<h3 id="STATIC-ROOT"><a href="#STATIC-ROOT" class="headerlink" title="STATIC_ROOT"></a>STATIC_ROOT</h3><p>실 서버 배포 시 static 파일을 <code>collectstatic</code> 하기위한 절대 경로이다. 기본 값은 <code>None</code>이며 다음과 같이 설정할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = <span class="string">"/var/www/example.com/static/"</span></span><br></pre></td></tr></table></figure>
<p>staticfiles contrib app이 활성화 되었을 때(기본적으로 Django 프로젝트를 생성하면 <code>INSTALLED_APPS</code>에 포함) ‘collectstatic’ 콘솔 명령어를 수행하면 해당 디렉터리로 static 파일들이 모인다.</p>
<h3 id="STATIC-URL"><a href="#STATIC-URL" class="headerlink" title="STATIC_URL"></a>STATIC_URL</h3><p>URL로써 static 파일의 위치를 가르킬 때 사용하는 위치이다. 마찬가지로 기본값은 <code>None</code>이며 아래와 같이 설정한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">"/static/"</span> <span class="keyword">or</span> <span class="string">"http://static.example.com/"</span></span><br></pre></td></tr></table></figure></p>
<p>주의 할 점은 마지막에 <code>/</code>를 꼭 붙여주어야 하고 <code>/</code>만 써서 root 경로를 가르키게 하면 안된다.</p>
<h3 id="STATICFILES-DIRS"><a href="#STATICFILES-DIRS" class="headerlink" title="STATICFILES_DIRS"></a>STATICFILES_DIRS</h3><p>앱에 포함된 static 파일의 위치를 추가할 수 있다. 기본값은 <code>[]</code>(비어있는 리스트) 이고, 아래와 같이 설정한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    <span class="string">"/home/special.polls.com/polls/static"</span>,</span><br><span class="line">    <span class="string">"/home/polls.com/polls/static"</span>,</span><br><span class="line">    <span class="string">"/opt/webfiles/common"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>앱에 포함된 기본 static 파일의 경로는 {APP_NAME}/static이다. manage.py의 커맨드 명령어인 <code>findstatic</code>을 수행하면 우리가 찾고자 하는 static 파일의 풀 경로를 보여준다.<br>이때 우선순위는 기본 앱의 경로보다 <code>STATICFILES_DIRS</code>에 명시된 경로가 먼저 사용된다.</p>
<h3 id="Prefixes"><a href="#Prefixes" class="headerlink" title="Prefixes"></a>Prefixes</h3><p>STATICFILES_DIRS 지정 시 Optional 속성으로 Prefix를 넣을 수 있다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    (<span class="string">"downloads"</span>, <span class="string">"/opt/webfiles/stats"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>예를 들어위처럼 <code>downlaods</code>라는 prefix를 넣으면 어떻게 될까? 해당경로에 있는 파일들은 <code>collectstatic</code> 명령을 내렸을때 <code>STATIC_ROOT</code>에서 지정한 폴더 하위에 <code>downloads</code>라는 폴더를 만들어 모이게 된다.<br>당연하게도 실제 제공되는 URL도 <code>STATIC_ROOT</code>에서 지정한 경로에 <code>downloads</code>를 붙여 제공하게 된다.</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref."></a>ref.</h3><ul>
<li><a href="http://blog.hannal.com/2015/04/start_with_django_webframework_06/" target="_blank" rel="noopener">http://blog.hannal.com/2015/04/start_with_django_webframework_06/</a></li>
<li><a href="http://tuwlab.com/ece/26571" target="_blank" rel="noopener">http://tuwlab.com/ece/26571</a></li>
<li><a href="https://docs.djangoproject.com/en/1.10/ref/contrib/staticfiles/#module-django.contrib.staticfiles" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.10/ref/contrib/staticfiles/#module-django.contrib.staticfiles</a></li>
<li><a href="https://docs.djangoproject.com/en/1.10/howto/static-files/deployment/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.10/howto/static-files/deployment/</a></li>
<li><a href="https://docs.djangoproject.com/en/1.10/howto/static-files/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.10/howto/static-files/</a></li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/11/14/django-static-file/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/23/t4-must-end-with-a-class-feature-error/">
                            Visual Studio T4 Template 오류
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-23T09:02:13+09:00">
	
		    2015-06-23
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/NET/">.NET</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="Visual-Studio-T4-Template-오류"><a href="#Visual-Studio-T4-Template-오류" class="headerlink" title="Visual Studio T4 Template 오류"></a>Visual Studio T4 Template 오류</h3><p>Visual Studio에서 제공하는 T4는 <code>Text Template Transformation Toolkit</code>의 약자인 TTTT를 줄인 말이다. 우리 회사에서는 <a href="https://msdn.microsoft.com/ko-kr/library/bb126445.aspx" target="_blank" rel="noopener">Visual Studio T4 Template</a>을 프레임워크 전반에 활용하고 있다.</p>
<p>예를들어 특정 폴더 밑에 있는 jsvascript나 css를 한대 묶어 <a href="http://www.asp.net/mvc/overview/performance/bundling-and-minification" target="_blank" rel="noopener">Bundle</a>을 코드를 자동 생성하기도 하고, 정해진 Generic type의 Interface만 선언하면 구현 class를 생성해주기도 한다.</p>
<p>어느날 T4 파일에서 아래와 같은 오류가 나는데 도무지 해결 방법을 찾을 수 없었다.<br><img src="https://crynut84.github.io/images/posts/t4-must-end-with-a-class-feature-error/t4-error.jpg" alt="T4 error message"></p>
<blockquote>
<p>A template containing a class feature must end with a class feature.</p>
</blockquote>
<p>오류 내용만 봐서는 마지막에 구문 오류가 있는지 아무리 살펴보아도 그런것은 찾을 수 없었다.<br>아래는 문제가 되는 코드의 마지막 부분 캡처이다.<br><img src="https://crynut84.github.io/images/posts/t4-must-end-with-a-class-feature-error/t4-code.jpg" alt="T4 code"></p>
<h5 id="A-template-containing-a-class-feature-must-end-with-a-class-feature-오류-해결-방법"><a href="#A-template-containing-a-class-feature-must-end-with-a-class-feature-오류-해결-방법" class="headerlink" title="A template containing a class feature must end with a class feature 오류 해결 방법"></a>A template containing a class feature must end with a class feature 오류 해결 방법</h5><p>결국 삽질 끝에 이 오류는 마지막에 보이지 않는 스페이스(공백)이 들어 있어서였다. 허무하다. 오류 내용이 친절하지 않지만 큰 의미에서 틀리지도 않았다.<br><img src="https://crynut84.github.io/images/posts/t4-must-end-with-a-class-feature-error/t4-solution.jpg" alt="T4 code"><br>위의 오류가 난다면 <strong>마지막의 공백을 제거</strong>하면 된다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/23/t4-must-end-with-a-class-feature-error/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/19/basic-command-git/">
                            git 기초 명령어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-19T08:52:48+09:00">
	
		    2015-06-19
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><a href="http://crynut84.github.io/2015-06-16/install-git.html">git을 설치</a>했다면 내 로컬에 완전한 git repository를 가질 수 있다는 것을 의미한다. 그럼 git을 이용해 어떻게 repository를 만들고 관리 할 수 있는지 기초 명령어를 알아보자.</p>
<p>아래와 같은 명령어를 다룰 것이다.</p>
<ul>
<li><a href="#git-config">git config</a> </li>
<li><a href="#git-init,-git-clone">git init, git-clone</a> </li>
<li><a href="#git-status">git status</a> </li>
<li><a href="#git-add">git add</a> </li>
<li><a href="#git-diff">git diff</a> </li>
<li><a href="#git-commit">git commit</a> </li>
<li><a href="#git-reset">git reset</a> </li>
<li><a href="#git-rm">git rm</a> </li>
<li><a href="#git-mv">git mv</a> </li>
<li><a href="#git-stash">git stash</a> </li>
</ul>
<p>이 11가지 명령어를 배우면 우리는 git을 사용해 프로젝트 파일의 생성, 수정, 삭제, 히스토리 관리를 할 수 있게 된다.</p>
<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>git을 설치하고 나서 제일 처음 할 일은 환경 설정을 하는 것이다. <code>config</code>라는 명령어로 환경 설정을 할 수 있는데 git의 환경 설정은 다음의 3곳에 저장된다.</p>
<ul>
<li>/etc/gitconfig<ul>
<li><code>git config --system</code> 옵션을 주었을 때 사용되는 파일</li>
<li>시스템의 모든 사용자, 모든 repository에 적용</li>
</ul>
</li>
<li>~/.gitconfig<br>-<code>git config --global</code> 옵션을 주었을 때 사용되는 파일<ul>
<li>홈디렉터리에 위치한 것으로 볼 수 있듯이 해당 시스템 사용자에게 적용</li>
</ul>
</li>
<li>./.git/config<ul>
<li>각 git repository에 위치한 설정 파일</li>
<li>repository 별 설정을 저장한다.</li>
</ul>
</li>
</ul>
<p>git의 설정은 IIS의 web.config 처럼 system -&gt; global -&gt; repository 순으로 상속된다.</p>
<h5 id="사용자-설정"><a href="#사용자-설정" class="headerlink" title="사용자 설정"></a>사용자 설정</h5><p>처음 설정이니 사용자 정보를 설정하여 보자. Linux나OS X는 terminal을 실행하고, Windows라면 git bash를 실행한다.</p>
<blockquote>
<p>$ git config –global user.name “Hojin, Jun”<br>$ git config –global user.email “crynut84@gmail.com”</p>
</blockquote>
<p>사용자명과 이메일을 설정하였다. git은 commit할 때 이 정보를 사용한다. <code>--global</code> 옵션에서 알 수 있듯이 시스템의 사용자에게 적용되는 옵션이다. <code>--global</code> 옵션을 빼고 각 repository 별로 설정 할 수 도 있다.</p>
<p><code>git config --list</code>로 모든 설정을 확일 할 수있고. <code>git config user.name</code>처럼 특정 설정을 확인 할 수도 있다.</p>
<h3 id="git-init-git-clone"><a href="#git-init-git-clone" class="headerlink" title="git init, git clone"></a>git init, git clone</h3><p>git repository를 만드는데는 2가지 방법이있다. 하나는 내 로컬의 디렉터리를 git repository로 만드는 것이고 원하는 디렉터리에서 아래 명령을 실행하기만 하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>이 명령을 실행하면 <strong>.git</strong> 이라는 디렉터리가 만들어지는데 이안에 있는 내용이 git이 repository를 관리하기 위한 파일이고 이후의 저장소 내부의 변화를 감지하기 시작한다. 그리고 <code>git init</code> 명령을 실행한 디렉터리를 <strong>working directory</strong>라고 부른다.</p>
<p>다른 하나는 이미 만들어져 있는 git repository를 <code>clone</code>하는 것이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
<p>clone 명령어를 이용해 가져 올 수 있는데 url은 repository의 주소이다. <a href="https://github.com" target="_blank" rel="noopener">github</a>를 기준으로 다음과 같이 clone 할 수 있는 url을 제공해 준다.<br><img src="http://crynut84.github.io/images/posts/basic-command-git/github-clone-url.jpg" alt="github clone url"></p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 명령으로 현재 repository의 현재 상태를 확인 할 수 있다. <code>git init</code> 명령어로 생성한 repository의 상태를 확인해보자.<br>!(git init)[<a href="https://crynut84.github.io/images/posts/basic-command-git/git-init.jpg">https://crynut84.github.io/images/posts/basic-command-git/git-init.jpg</a>]<br>branch가 master(git의 기본 branch명)인 것과 commit이 없으니 파일을 생성/복사한 후 <code>git add</code> 명령으로 트래킹하라는 메세지를 볼 수 있다.</p>
<p>a.txt라는 빈 텍스트 파일을 생성한 후 <code>git status</code> 명령어로 확인 해보면 아래와 같이 <strong>Untracked files</strong> 목록에 a.txt 파일을 볼 수 있다.<br><img src="https://crynut84.github.io/images/posts/basic-command-git/git-status-after-add-file.jpg" alt="git status after add file"><br>이 상태를 이해하기 위해서는 먼저 git의 working directory에 있는 파일의 라이프사이클에 대해 알 필요가 있다.<br><img src="https://crynut84.github.io/images/posts/basic-command-git/lifecycle.jpg" alt="git file life cycle"></p>
<p>위의 그림에서 알 수 있듯이 파일은 관리되는 파일(Tracked)과 관리되지 않는 파일(Untracked)로 나뉜다.</p>
<ul>
<li>Tracked<br>파일의 상태를 감시한다. 파일의 상태를 아래 3가지로 분류하여 관리한다.</li>
<li>Unmodified<br>파일의 변경이 없는 상태</li>
<li>Modified<br>파일이 수정된 상태</li>
<li>Staged<br>Modified 상태의 파일을 commit 하려면 Stated 상태로 만들어야한다.</li>
<li>Untracked<br>파일의 상태를 감시하지 않는다.</li>
</ul>
<p>이제 앞서 추가한 a.txt 파일이 <strong>Untracked</strong> 상태인것이 이해 될 것이다. 우리가 처음으로 파일을 추가하면 Untracked 상태로 추가된다.</p>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>그럼 a.txt파일을 <code>git add</code> 명령어로 추가해보자. git add [파일명]으로 추가 할 수 있다.</p>
<blockquote>
<p>$ git add a.txt</p>
</blockquote>
<p><img src="https://crynut84.github.io/images/posts/basic-command-git/git-stated-file.jpg" alt="git stated file status"><br>이렇게 Untracked 상태인 파일을 add하면 Stated 상태가 된다. 앞서 설명했듯이 Staged 상태의 파일은 commit에 포함되는 대상이 된다.</p>
<p>아직 배우지 않았지만 <code>git commit</code> 명령어를 이용하여 commit을 해보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'first commit'</span></span><br><span class="line">[master (root-commit) 5488e51] first commit</span><br><span class="line">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 a.txt</span><br></pre></td></tr></table></figure>
<p>1개의 파일(a.txt)가 commit 된것을 확인 할 수 있다. 다시 <code>git status</code>로 상태를 확인해보면 commit 할 것이 없으며 working directory도 클린하다고 알려준다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>이 상태에서 a.txt 파일을 수정해 보자. 수정하면 자연스럽게 modified 상태로 바뀔 것 임을 예상 할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'파일 수정'</span> &gt; a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	**modified:   a.txt**</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>이제 <code>git add</code> 명령을 실행하면 a.txt는 다시 Staged 상태가 되고, commit의 대상이 된다. 즉 <code>git add</code>명령은 <em>Untracked 상태이거나 Modified 상태인 파일을 Staged 상태</em>로 바꾸는 명령어이다.</p>
<p>Staged 상태에 대해 더 자세히 알아보기 위해 `git add’하고 파일을 한번 더 수정해 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'파일을 한번 더 수정'</span> &gt; a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">**Changes to be committed:**</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br><span class="line"></span><br><span class="line">**Changes not staged <span class="keyword">for</span> commit:**</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br></pre></td></tr></table></figure>
<p>a.txt의 상태가 두개가 되었다. 어떻게 된 것일까? 이 개념이 아주 중요한데, <strong>Stated 상태라는 것은 <code>git add</code>할 당시의 파일을 스냅샷</strong>이라는 것이다. 위에 있는 Stated 상태의 a.txt의 내용은 <code>git add</code>를 했을 당시 내용인 ‘파일 수정’이라는 문구가 있을 것이고 UnStated 상태의 a.txt 파일에 내용은 ‘파일을 한번 더 수정’이라는 문구가 들어 있을 것이다. 만약 이 상태로 <code>commit</code>을 수행하면 Staged 상태의 내용인 ‘파일 수정’ 문구가 들어있는 a.txt의 스냅샷이 commit 된다.</p>
<p>마지막으로 수정한 정보까지 포함하여 commit 하고 싶다면 <code>git add</code> 명령으로 한번 더 a.txt를 추가 해 주면 된다.</p>
<p>추가로 일반적으로 프로젝트를 수행하면 여러 파일을 추가/수정 하는 일이 많을 텐데, 그런경우 <code>git add *.js</code> 나 <code>git add .</code> 같이 한번에 여러 파일을 add 하는 방법도 있다.</p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>위의 예에서 보았듯이 Staged 상태라는 것은 <code>git add</code> 할 당시의 파일의 스냅샷이다. 그런데 개발을 하다보면 <code>git add</code>한 파일을 무심코 다시 수정하고 그냥 commit하는 실수가 있을 것 같다.<br><code>git diff</code>명령은 이럴 때 유용한 명령인데, Staging 영역(Stated된 스냅샷을 모아놓은 영역)과 Working Directory의 차이를 보여준다.<br>위의 예제에서 <code>git diff</code> 명령을 수행해 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/a.txt b/a.txt</span><br><span class="line">index ecb3871..40efd75 100644</span><br><span class="line">\--- a/a.txt</span><br><span class="line">+++ b/a.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-파일 수정</span><br><span class="line">+파일을 한번 더 수정</span><br></pre></td></tr></table></figure>
<p>Staging 영역에는 ‘파일 수정’이라는 내용의 파일이 Working 영역에는 ‘파일을 한번 더 수정’이라는 내용의 파일이 들어있는 것을 볼 수 있다.<br>commit을 수행하기 전에는 항상 <code>git status</code>로 내가 포함 할 파일의 목록이 정확히 포함 되었는지 확인 하고 <code>git diff</code> 명령으로 staging 영역과 working 영역의 차이가 없는지 살피는 습관을 들인다면 commit을 실수하는 일을 줄 일 수 있을 것이다.</p>
<p>추가로 Staged 상태와 이전 commit의 상태를 비교해 보려면 <code>git diff --cached</code> 옵션을 붙여서 실행하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/a.txt b/a.txt</span><br><span class="line">index e69de29..ecb3871 100644</span><br><span class="line">\--- a/a.txt</span><br><span class="line">+++ b/a.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+파일 수정</span><br></pre></td></tr></table></figure>
<p>이전 상태의 commit에서 a.txt는 빈파일이었으니 아무것도 나오지 않았고 현재 Stated 상태의 a.txt는 ‘파일 수정’이라는 문구가 추가로 들어갔다는 것을 볼 수 있다.</p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>드디어 git에서 가장 중요한 명령어 중 하나인 <code>git commit</code> 명령어를 소개 할 차례이다. commit은 하나의 작업단위(변경사항)를 local repository에 기록하는 것이다.</p>
<p>그럼 하나의 commit은 언제 만드는 것이 좋을까? 프로젝트를 수행함에 있어, 코드를 변경한다는 것은 어떠한 목적(요구사항)을 달성하기 위한 행위이다. 나는 이슈관리시스템(TFS)에서 하나의 Backlog item이나 Bug item을 할당 받으면 그것을 분석하여, 논리적으로 묶일 수 있는(혹은 다른 코드에 영향이 없을단위)로 쪼개서 하위 Task를 생성한다. 그리고 이 Task를 commit과 1:1로 맵핑 시킬 수 있도록 노력하는 편이다. 그렇기에 어떤 commit에는 100개의 파일이 추가/수정/삭제되어 있을 수도 있고, 어떤 commit에는 단하나의 파일만 수정되어 있을수도 있다. commit의 단위는 자유롭게 설정하여 사용 할 수 있기 때문에 어떻게 제한 할 지는 각 프로젝트의 상황이나 팀원간의 합의에 따라 적절하게 정하면 된다.<br>다만 commit을 작성하는데 참고가 될만한 글을 소개한다.<br><a href="http://haruair.com/blog/2683" target="_blank" rel="noopener">커밋 메시지에 대해</a>라는 제목의 글인데 커밋메세지를 작성하는 방법에대해 토론한 내용을 정리한 글이다.</p>
<blockquote>
<p>변경 사항에 따라 로직을 이해할 수 있는 수준의 단일 커밋 단위로 쪼개야 한다.</p>
</blockquote>
<p>커밋 메세지를 작성하는 방법에서 커밋의 단위를 어떻게 가져가야 할지 예측해 볼 수 있을 것이다.</p>
<p>위의 예제를 계속 이어가기 위해 a.txt를 stating 영역으로 add하고 git status로 변경 사항을 확인한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br></pre></td></tr></table></figure>
<p>이 상태에서 <code>git commit&#39; 명령을 수행하면 commit 메세지를 적을 수 있는 text-editor가 실행된다.
!(github clone url)[https://crynut84.github.io/images/posts/basic-command-git/git-commit-editor.png]
이 editor는</code>git config –global core.editor<code>명령으로 변경 가능하다. editor를 실행하면 여러줄의 commit 메세지를 작성 할 수 있고, 한줄의 짧은 메세지로 commit 할 경우에는 위의 예제에서 실행 했듯이</code>-m’ 옵션을 주어 짧은 commit을 실행 할 수도 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'my commit message'</span></span><br><span class="line">[master ac05efa] my commit message</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>모든 변경사항을 commit한 후 <code>git status</code>명령으로 상태를 확인하면 위와같이 working directory가 깨끗하다는 메세지를 확인 할 수 있다. 모든 변경사항이 commit 된 것이다. 한번 commit한 사항은 local repository에 저장되기에 언제든 조회,복구 할 수 있다. 특별한 일이 없는 한 commit된 것은 날아가지 않는다.(remote server에 push한 경우에는 더더욱) 하지만 commit 하지 않은 것은 언제든 잃어 버릴 수 있다.</p>
<p>또한 위의 링크에서도 알 수 있듯이 우리는 commit 메세지 작성을 잘 해야한다. commit 메세지가 잘 작성된 경우에는 commit 메세지를 확인 하는 것만으로도 프로젝트의 히스토리를 파악 할 수 있다.</p>
<p>추가로 <code>git add</code>하지 않은 Working영역의 Tracked file을 모두 커밋하고자 할때에는 <code>-a</code>옵션을 사용한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">'commit all tracked files'</span></span><br></pre></td></tr></table></figure>
<p><code>-a</code> 옵션을 사용경우 git은 Working영역의 파일을 stating 영역에 넣고, commit하는 것과 동일한 결과를 준다.</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>프로젝트 파일을 수정 할 때 어떠한 목적을 가지고(하나의 commit에 묶일 수 있도록) 파일을 수정하겠지만, 사람이 하는 일이 항상 마음 먹은대로되는 것은 아니다. a.txt파일을 수정하는 미션을 받고 수정하는 중에 b.txt파일을 추가 했다고 가정해 보자. 논리적으로 a.txt파일을 수정한것만 하나의 commit으로 묶어야한다면, a.txt 파일을 <code>git add</code>하여 Stating 영역에 넣고 commit 하면 된다. 그런데 실수로 b.txt파일도 Stating 영역에 들어갔다면 b.txt파일을 다시 working 영역으로 옮기는 방법이 필요하다.</p>
<p>이럴 때 ‘git reset’명령을 사용하면 된다. 실습을 위해 a.txt파일을 수정하고, b.txt파일을 새로 만들어 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'modify a.txt file'</span> &gt; a.txt</span><br><span class="line">$ cat &gt; b.txt</span><br><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br><span class="line">	new file:   b.txt</span><br></pre></td></tr></table></figure>
<p><code>git add *</code> 명령으로 모든 변경사항이 stating 영역에 포함되었다. 이 상태에서 commit하면 a.txt,b.txt두개의 파일이 commit 될 것이다. b.txt를 commit에서 제외하기 위해 아래와 같이 <code>git reset</code> 명령어를 수행해 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD b.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   a.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	b.txt</span><br></pre></td></tr></table></figure>
<p>b.txt파일이 이전 상태로 돌아간 것을 확인 할 수 있다. 이처럼 <code>git reset</code>은  staging 영역에서 working 영역으로 되돌리는 역할을하고, 이를 이용해 commit이 포함될 파일을 조절 할 수 있다.</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>git이 관리하는(Tracked) 파일을 삭제하려면 어떻게 해야할까? 윈도우의 탐색기나 OSX의 Finder에서 파일을 삭제하거나 Terminal에서 RM 명령을 통해 삭제하면 된다.</p>
<p>위의 예제에서 working directory를 clean한 상태로 만들고 이어서 실습해 보자.(clean하게 하려면 commit 하면 된다.)<br>a.txt파일만 있는 상황에서 terminal에서 rm 명령을 이용해 파일을 삭제한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rm a.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    a.txt</span><br></pre></td></tr></table></figure>
<p>git은 파일의 삭제도 훌륭하게 추적하여 파일이 삭제되었음을 알려준다. 이 상태에서 <code>git add</code>명령어로 staging 영역에 추가하고 <code>git commit</code>하면 파일이 삭제된 스냅샷이 git repository에 저장 될 것이다.(앞서 배웠듯이 <code>git -a commit</code>명령으로 한번에 add+commit 할 수도 있다.)</p>
<p>git에서도 <code>git rm</code>이라는 명령어를 제공한다. 그냥 삭제해도 git이 알아서 인식하는데 왜 별도의 명령을 제공하는 것일까? 그냥 파일을 삭제해도 되지만 명령어는 몇가지 기능이 더 있다.<br>기본적으로 <code>git rm</code> 명령을 통해 파일을 삭제하면 파일을 삭제하고 자동으로 staging 영역으로 넣어준다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rm a.txt</span><br><span class="line">rm <span class="string">'a.txt'</span></span><br><span class="line">$ ls -l</span><br><span class="line">total 0</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	deleted:    a.txt</span><br></pre></td></tr></table></figure>
<p>그리고 이미 staging 영역으로 들어간 파일을 물리적으로 삭제하면 다음과 같이 2개의 상태를 가지게 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	deleted:    a.txt</span><br><span class="line">   new file:   b.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    b.txt</span><br></pre></td></tr></table></figure>
<p>b.txt가 새로 생성되었고, 삭제된 상태이다. git은 실수로 삭제하는 것을 막기위해서 이런 방법을 사용한다. <code>git rm -f</code> 옵션을 사용하면 바로 삭제처리도 가능하다.</p>
<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p><code>git mv</code>명령은 파일을 이동하는 명령이다. 이동이라는 것은 경로를 바꾼다는 뜻이며, 파일의 이름을 변경하는 행위와도 같다. 사용법도 아주 쉽다. 아래를 참조하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git mv a.txt c.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	renamed:    a.txt -&gt; c.txt</span><br></pre></td></tr></table></figure>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>TFS를 사용할 때 Shelve(보류)라는 기능을 유용하게 사용했었다. 이런 시나리오는 생각해보자. 어떤 Task를 할당받아 열심히 개발하는 중에 치명적인 버그가 발견되었다. 급하게 Hot Patch를 내놓아야 하는 상황에서 선택 할 수 있는 방법은 두가지이다.</p>
<p>하나는 현재 개발 중인 Task를 최대한 빨리 마무리하고, Hot Patch를 개발하는 방법이고, 또하나는 현재 진행하던 Task를 버리고(되돌리고) 급한 패치부터 개발하는 방법이다. Shelve는 이럴때 유용하게 사용 할 수 있는데 진행하던 Task를 보류시켜 놓고(어딘가에 저장) 이전 상태로 돌아가 Hot Patch를 만들어 checkin한 후 다시 보류된 작업을 꺼내와서 Task를 이어서 진행하는 방법이다.</p>
<p>git에도 <code>git stash</code> 명령어를 통해서 위와같은 시나리오에 대응 할 수 있다. 파일을 변경한 상태에서 (즉 워킹 디렉토리가 clean하지 않은 상태) <code>git stash</code> 명령을 사용하고 <code>git staus</code>명령으로 상태를 확인하면 아래와 같이 clean 한 상태가 된다. 이때 위의 시나리오처럼 다른 작업을 할 수 있는 것이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'change c.txt'</span> &gt; c.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   c.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">rynut84@ubuntu:~/work/git-test git stash</span><br><span class="line">Saved working directory and index state WIP on master: da3fe70 rename a.txt -&gt; c.txt</span><br><span class="line">HEAD is now at da3fe70 rename a.txt -&gt; c.txt</span><br><span class="line">crynut84@ubuntu:~/work/git-test$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>또한 stash 된 목록을 <code>git stash list</code> 명령으로 확인 할 수 있고, stashing 한 목록을 복원하려면, `git stash pop’ 명령을 이용하면 된다.</p>
<p>총 11가지 명령으로 git의 local repository를 다루는 방법을 배웠다. git이 가진 명령어는 지금 소개한것보다 훨씬 많지만(옵션까지 하면 더 많다) 이정도만 알아도 크게 불편한 점이 없었고, 더 자세한 기능은 그때그때 찾아보면서 쓰는 편이다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/19/basic-command-git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/16/install-git/">
                            git 간단 개념과 설치 방법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-16T08:46:53+09:00">
	
		    2015-06-16
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>이전 포스팅에서 <a href="https://crynut84.github.io/2015-06-10/introduction-to-git.html">분산 버전 관리 시스템의 개념</a>을 살펴보았으니, 대표적인  분산 버전 관리 시스템인 git에 대해 알아보려 한다.</p>
<p>git <a href="http://git-scm.com" target="_blank" rel="noopener">공식 사이트</a> 메인페이지에 보면 git을 아래와 같이 소개한다.</p>
<blockquote>
<p><strong><em>Git is easy to learn</em></strong> and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.</p>
</blockquote>
<p>배우기 쉽다는 것인데, 내가 처음 git을 배울 때는 다음과 같은 이유로 git이 무지 어려웠다.</p>
<ul>
<li>.NET을 주 언어로 사용하는 개발자로 윈도우의 GUI 환경에 익숙하다.<ul>
<li>git GUI 환경이 있기는 하지만 결국 CLI을 알아야 한다.</li>
</ul>
</li>
<li>기존에 사용하던 버전 관리 시스템(TFS, SVN등)의 개념으로 이해하려 했다.<ul>
<li>git을 배우려면 기존의 생각을 버리는게 더 빠르다.</li>
</ul>
</li>
<li>git과 <a href="https://github.com/" target="_blank" rel="noopener">github</a>의 개념을 혼동.<ul>
<li>github는 git 기반의 온라인 소스 관리 서비스이다.</li>
<li>많은 자료에서 git과 github를 함께 설명하다 보니 해깔렸다.</li>
</ul>
</li>
</ul>
<p>그래서 나는 순수(?) git을 기능을 먼저 알아보려고 한다.</p>
<h2 id="git-소개"><a href="#git-소개" class="headerlink" title="git 소개"></a>git 소개</h2><p>git은 <a href="http://git-scm.com" target="_blank" rel="noopener">공식 사이트</a>에 document가 굉장히 잘 만들어져 있다. 요즘 오픈소스는 대부분 document에 공을 들이는 것 같다. 고마운 분들이 번역해 놓은 <a href="http://git-scm.com/book/ko/v2" target="_blank" rel="noopener">한글판</a>도 있다. 덕분에 특별히 책을 구입하지 않아도 배울 수 있다.</p>
<p><a href="http://git-scm.com/about" target="_blank" rel="noopener">About 페이지</a>에가보면 다음의 6가지 주제로 git을 소개하고 있다. 이 개념들이 기존 버전관리 시스템과 다른점이고 git을 사용하면서 얻을 수 있는 이점이다.</p>
<ul>
<li>Branching and Merging</li>
<li>Small and Fast</li>
<li>Distributed</li>
<li>Data Assurance</li>
<li>Staging Area</li>
<li>Free and Open Source</li>
</ul>
<h3 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h3><p>git은 branch를 만드는데 부담이 없다. 그렇기 때문에 작은 단위의 기능으로 새 branch를 만들고 거기에 원하는 기능을 개발하거나, 실험하고 싶었던 기능을 실험 할 수 있다.  실험에 실패한다면? 그냥 branch를 버리는것으로 끝난다. 아무런 사이드 이펙트가 없다. 나는 TFS를 이용할 때 Branch를 만들때마다 부담스러웠다. 만드는 속도, 용량등 자주 만들기에는 너무 큰 부담이었고(덕분에 회사에 품의를 올려 256G SSD를 추가 구매 할 수 있었지만..) git을 사용하면 이런 고민을 조금은 덜 수 있다.</p>
<p>git은 branch를 만들어 구현하고, 구현한것을 commit 하고, 때때로 원래 branch로 돌아가 심각한 버그에대한 hotpatch를 만들 수 있다.</p>
<h3 id="Small-and-Fast"><a href="#Small-and-Fast" class="headerlink" title="Small and Fast"></a>Small and Fast</h3><p>branch를 만들고 merge하는 것이 부담스럽다면, 위와같은 작업을 할 수 없을 것이다. git은 거의 모든 작업을 local repository에서 수행하기 때문에 속도가 빠르다. 심지어 branch를 만들때도 remote server가 없어도 된다. 나중에 설명 하겠지만 git의 branch는 commit을 가르키는 포인터일 뿐이고, 그렇기 때문에 branch를 만드는 것 또한 빠르고 작은 용량으로 가능하다.</p>
<h3 id="Distributed"><a href="#Distributed" class="headerlink" title="Distributed"></a>Distributed</h3><p>분산 저장소는, 모든 사용자들이 온전한 git repository를 가진다는 의미이다. 내가 진행중인 프로젝트를 git을 이용하여 내려받는다면, 나는 remote repository와 동일한 repository를 내 local에 가져오게 된다. 이말을 바꿔말하면 단지 repository를 가져오는 것만으로 source, commit hitsotry등 모든 요소를 가져오게 된다는 말인다. 최악의 경우 remote server의 장애로 모든 데이터를 날렸다고 하더라도, 다른 사용자의 repository를 이용해 복원 할 수 있다는 말인다.</p>
<p>그리고, 개발자들은 각자의 repository에서 작업하고(네트워크 없이) 작업이 끝난경우 remote repository로 push하여 개발 할 수 있고, git을 활용하여 업무의 workflow를 유연하게 적용 할 수 있다.<br><img src="https://git-scm.com/images/about/workflow-b@2x.png" alt="Integration Manager Workflow"><br>출처 : <a href="https://git-scm.com/images/about/workflow-b@2x.png" target="_blank" rel="noopener">https://git-scm.com/images/about/workflow-b@2x.png</a></p>
<h3 id="Data-Assurance"><a href="#Data-Assurance" class="headerlink" title="Data Assurance"></a>Data Assurance</h3><p>git은 관리하는 모든 파일을 암호화하여 보관하고, 체크썸을 이용하여 파일의 유효성을 보장한다. 그리고 각 commit에는 commit 아이디가 부여되여 관리 되기 때문에 hitory 관리에도 유용하게 적용 할 수 있다.</p>
<h3 id="Staging-Area"><a href="#Staging-Area" class="headerlink" title="Staging Area"></a>Staging Area</h3><p>처음 git을 접하면 어렵게 느껴지는 부분인데 git에는 다른 VCS에는 없는 <code>staging area</code>가 있다.(index라고도 부름)<br><img src="https://git-scm.com/images/about/index1@2x.png" alt="Git staging area"><br>출처 : <a href="https://git-scm.com/images/about/index1@2x.png" target="_blank" rel="noopener">https://git-scm.com/images/about/index1@2x.png</a></p>
<p>파일들은 working directory에 있다. 이 상태에서 a.txt파일을 수정하면 파일의 상태가 modified로 바뀌고, 예상하는 바와같이 commit을 하면 a.txt가 commit 될 것처럼 보인다. 하지만 git에서는 이렇게 동작하지 않는다. modiried 상태인 a.txt파일을 staging area로 등록해야만 commit에 포함된다. 즉 git은 stating area의 스냅샷을 commit으로 기록하는 것이다.</p>
<h3 id="Free-and-Open-Source"><a href="#Free-and-Open-Source" class="headerlink" title="Free and Open Source"></a>Free and Open Source</h3><p>git은 <a href="http://opensource.org/licenses/GPL-2.0" target="_blank" rel="noopener">GNU General Public License version 2.0</a> 라이선스 정책을 따르고 있으며, 모든 사용자에게 무료로 제공된다. 주의할 점은 git의 <a href="http://git-scm.com/downloads/logos" target="_blank" rel="noopener">로고</a>는 다른 <a href="http://git-scm.com/trademark" target="_blank" rel="noopener">라이선스 정책</a>을 따른다는 것이다.</p>
<h2 id="git-설치"><a href="#git-설치" class="headerlink" title="git 설치"></a>git 설치</h2><p>git을 설치하는데는 큰 어려움이 없다. Linux와 Mac OS X, Windows의 버전이 조금씩 다른데, <a href="http://git-scm.com/downloads" target="_blank" rel="noopener">Downloads</a> 페이지에서 각 OS별 download를 제공한다.</p>
<h3 id="Windows에-설치"><a href="#Windows에-설치" class="headerlink" title="Windows에 설치"></a>Windows에 설치</h3><p>Windows의 경우 download 페이지에 가면 설치파일이 제공된다. 다운로드받아 설치하는것으로 쉽게 가능하다. 설치 후 git bash를 이용하여 사용하면 된다.</p>
<h3 id="Linux에-설치"><a href="#Linux에-설치" class="headerlink" title="Linux에 설치"></a>Linux에 설치</h3><p>Ubuntu의 경우 apt-get(pakage manager)를 이용하여 쉽게 설치할 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install git</span><br></pre></td></tr></table></figure></p>
<h3 id="Mac에-설치"><a href="#Mac에-설치" class="headerlink" title="Mac에 설치"></a>Mac에 설치</h3><p>Mac의 경우에도 download 페이지에서 installer를 제공하기 때문에 손쉽게 설치 가능하다.</p>
<p>어떤 OS든 git 설치가 되었는지 확인하려면 git의 버전을 보는 명령어를 실행하여 현재 git의 버전을 확인할 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure></p>
<p><img src="https://crynut84.github.io/images/posts/install-git/git-version.png" alt="git version"></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/16/install-git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/10/introduction-to-git/">
                            분산 버전 관리 시스템 git 소개
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-10T08:40:44+09:00">
	
		    2015-06-10
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>2010년 대학교 졸업 후 취업 할 생각은 안하고 빈둥거리고 있을 때, 지인의 소개로 모 회사의 SI 프로젝트에 프리랜서 자격으로 참여 할 수 있었다. </p>
<p>프리랜서이지만 나름 첫 출근날, 상콤한 마음으로 프로젝트 장소에 도착하여 간략하게 개발업무에 대한 설명을 듣고, 개발환경을 구축하려는 그때부터 나는 멘붕에 빠져버렸다.</p>
<p>사실 대학교 막 졸업한 내가 제대로 할 줄 아는것이 무었이 있었겠는가? 그냥 다 할 줄 안다고 패기있게 참여한 프로젝트였지만 첫 시작부터 예상치 못한 친구인 “버전 관리 시스템”을 만나게 되었다. 당시 그 업체에서는 <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_SourceSafe" target="_blank" rel="noopener">Visual Source Safe</a>라는 툴을 사용하고 있었는데, 버전 관리 시스템이라것을 거기서 처음 들은 나는 Source Safe에서 소스 받아가라는 PL의 말을 알아듣지 못 할 수 밖에..</p>
<p>대학에서 친구 몇 명과 조그만 프로젝트를 개발 할 때는 한명이 프로젝트를 생성하여 큰 틀을 만들고, 각자 역할에 나누어 개발 후 한 사람 PC에 옹기종기 모여 각자 개발 한 모듈을 USB에 담아 취합하는 작업을 했었다. </p>
<p>시스템이 복잡하면 할 수록 점점 소스를 취합하는것이 힘들어 질 것이다. 그리고 특정 파일을 3일전의 상태로 돌리고 싶다면 어떨까? 매일매일 소스를 백업하여 아래같이 해둔다면 어찌 해 볼 수 있겠지만 그마저도 없다면 오롯이 내 머릿속의 기억에만 의존해야하는 최악의 사태가 벌어 질 수 있다.  </p>
<ul>
<li>2015-06-01.zip  </li>
<li>2015-06-02.zip  </li>
<li>2015-06-03.zip   </li>
</ul>
<p>어떻게 이런 문제들을 해결 할 수 있을까?</p>
<h2 id="버전-관리-Version-Control-란"><a href="#버전-관리-Version-Control-란" class="headerlink" title="버전 관리(Version Control)란?"></a>버전 관리(Version Control)란?</h2><p>개발자들은 자신의 머리가 그리 똑똑하지 못하는다는것을 오래전에 깨닫고 파일의 변화를 기록하는 시스템을 만들었으니 그게 버전관리 시스템이다.</p>
<p>아마 처음에는 자신의 컴퓨터에 있는 파일의 버전을 관리해주는 프로그램을 개발 했을 것이다.<br>내가 짠 소스코드의 변화를 시스템이 관리해주니 오늘 수정한 소스가 잘못된 것을 알았을 때 손쉽게 그 이전 버전이나, 특정 날짜에 작성한 버전으로 돌릴 수 있었을 것이다. </p>
<p>하지만, 소프트웨어는 여럿이 개발하는 경우가 많으므로, 내가 작성한 코드가 다른 사람에게도 보였으면 하는 생각이 들었을 것이고, 내 로컬에 변경사항을 기록하는 것이 아닌, 소스를 관리하는 서버에 변경사항을 기록하고, 각자 서버에서 소스를 받아서 사용할 수 있는 시스템을 만들었다. 그게 현재 사용하는 TFS, Source Safe, SVN, Subversion과 같은 프로그램이고 이것을 중앙 집중형 버전관리 시스템이라고 한다.</p>
<p>이 프로그램을 사용하면 다음과 같은 장점을 누릴 수 있다.      </p>
<ul>
<li>여러명의 개발자가 하나의 프로젝트를 동시에 개발 할 수 있다.</li>
<li>USB등으로 파일을 copy할 필요 없이 다른 사람이 개발한 소스코드를 내 컴퓨터에 받아 올 수 있다.</li>
<li>이 파일을 누가 언제 어떻게 수정했는지 이력을 볼 수 있다.</li>
<li>문제가 생겨 이전 버전으로 돌아가야하는 일이 생겼을 때 손쉽게 돌아 갈 수 있다.</li>
<li>Branch를 이용하여, 좀 더 안전하게 새 기능을 추가하고 Merge하여 통합 할 수 있다.</li>
<li>내가 A 기능을 개발하는 중에 급하게 Patch해야 할 버그가 생겼을 때도 잠시 A기능을 개발하지 전 상태로 돌려 버그를 수정하고, 다시 A기능을 개발하던 상태로 돌아 갈 수 있다. </li>
</ul>
<p>이렇게 많은 기능을 제공하니, 개발자들은 좀 더 편리하게 개발 할 수 있게 된 것이다. </p>
<p><img src="https://crynut84.github.io/images/posts/introduction-to-git/centralized-version-control.png" alt="중앙집중형 버전관리 시스템"><br>출처 : <a href="https://homes.cs.washington.edu/~mernst/advice/version-control.html" target="_blank" rel="noopener">https://homes.cs.washington.edu/~mernst/advice/version-control.html</a></p>
<p>나는 그동안 <a href="https://msdn.microsoft.com/ko-kr/vstudio/ff637362.aspx" target="_blank" rel="noopener">TFS(Team Foundation Server)</a>를 이용하여 버전관리를 했는데 IDE인 Visual Studio와의 통합도 훌륭하기 때문에 큰 불편함 없이 사용해왔다. </p>
<p>하지만 TFS(중앙 집중형 버전관리 시스템)의 경우 모든 소스를 서버가 관리하기 때문에 다음과 같은 단점이 존재한다.</p>
<ul>
<li>네트워크에 연결되어 있어야만 작업이 가능하다.(소스파일의 checkin, checkout시 서버에 접솝해야 한다.)   </li>
<li>서버에 문제가 생기면 작업을 할 수 없다.   </li>
<li>서버와의 통신이 지속적으로 이루어지기 때문에 네트워크가 느린경우 작업에도 영향을 미친다.   </li>
<li>Branch하면 전체 소스를 다른 폴더에 받아오기 때문에 Branch가 많이 부담스러운 작업이다.</li>
</ul>
<p>분산 버전 관리 시스템을 사용하면 앞서 말한 문제점을 해결 할 수 있다.</p>
<h2 id="분산-버전-관리-시스템"><a href="#분산-버전-관리-시스템" class="headerlink" title="분산 버전 관리 시스템"></a>분산 버전 관리 시스템</h2><p>중앙집중형 버전관리 시스템의 저장소(repository)가 server에만 있는것과 달리 분산 버전 관리 시스템에서 저장소는 모든 client가 저장소가 될 수 있다. 이게 무슨 말일까?</p>
<p>예를들어 TFS에서 get latest version을 통해 저장소에서 project를 가져온가고 생각해 보자. 그럼 저장소에서 사용자의 컴퓨터에 최신의 코드를 받아오게 된다. 분산 버전 관리 시스템의 경우 어떻까? server에서 저장소자체를 통채로 받아오게 된다. 이 말은 소스코드는 물론 그동안의 변경 이력까지 모든 정보를 가져와 로컬 컴퓨터 또한 완전한 저장소가 된다는 뜻이다.</p>
<p>이렇게 됨으로써 한번 저장소를 받아온 이후에 개발작업에서는 서버와는 별개로 자신의 로컬에서 진행하게 되고, 로컬이니 당연히 빠른 속도로 변경 할 수 있는 것이다. 만약 main.cs 파일의 지난 히스토리와 diff 하고 싶을 경우 TFS는 서버와의 통신을 통해 diff하는 반면 분산 버전 관리 시스템은 로컬에 있는 저장소에서 변경 이력을 찾아 diff해 준다.</p>
<p>이런 분산 버전 관리 시스템의 개념을 구현한 것이 git, Mercurial등이 있고, 나는 이제는 대새(?)로 자리잡은 git에 대해 설명 하려고한다. git은 리누즈 토발즈가 리눅스 커널의 버전관리를 위해 만들었다고 알려져 있다. </p>
<h2 id="왜-git으로-바꿔야하나"><a href="#왜-git으로-바꿔야하나" class="headerlink" title="왜 git으로 바꿔야하나?"></a>왜 git으로 바꿔야하나?</h2><p>git은 어렵다. git을 만든 리누즈 토발즈도 한 <a href="http://www.looah.com/article/view/1692" target="_blank" rel="noopener">인터뷰</a>에서 <code>이렇게 쓰기 어려운걸 누가 쓰리라곤 생각도 못했다.</code>고 말했라고 한다. 특히나 CLI보다 GUI가 익숙한 닷넷 개발자는(닷넷개발자가 다 그렇다는 것이 아니다) 인터넷에 있는 git에 대한 사용법을 담은 자료를 보고, <code>버전 관리하는데 머가 이렇게 어려워?</code>라는 생각을 가질 만하다.</p>
<p>우리 <a href="https://www.yooniqimages.com" target="_blank" rel="noopener">회사</a>에서는 올해 초부터 시작해서 6개월동안 git을 사용하기 시작했는데, 내가 생각하는 장점은 다음과 같다.</p>
<ul>
<li>저장소 서버가 느려서 스트레스 받는 일이 줄었다.(우리는 <a href="https://www.visualstudio.com/en-us/products/what-is-visual-studio-online-vs.aspx" target="_blank" rel="noopener">Visual Studio Online</a> 서비스를 이용하고 있는데 서버가 미국에 있다.) </li>
<li>Branch를 마음껏 할 수 있어, Backlog나 Bug 단위로 Branch를 만들어 개발하고 프로덕트를 release하는 Branch(master)는 clean하게 유지할 수 있다.(git workflow) -&gt; 나는 이것이 git을 사용하는 가장 큰 benefit이라고 생각한다. </li>
</ul>
<p>이 외에도 만약 이런 상태라면 git을 쓰자.</p>
<ul>
<li>버전관리 시스템을 써본적이 없다. 하지만 이제부터 쓸 예정이다.</li>
<li>github 서비스를 remote 저장소로 사용 할 예정이다.</li>
<li>머릿속에 프로젝트에 대한 새로운 아이디어가 넘치는데 중앙의 source 이력을 망가뜨리지 않고 마구 실험해 보고 싶다. </li>
<li>오픈소스의 컨트리뷰터가 되고 싶을 때(많은 오픈소스가 git으로 진행되거나 전환하고 있다)</li>
<li>git이 대세라는데 그 이유가 궁금하다.(써보면 안다)</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/10/introduction-to-git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/03/install-nodejs/">
                            node.js 소개 및 설치
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-03T08:13:47+09:00">
	
		    2015-06-03
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/node/">node</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>벌써 개발자로 살아온지 만 5년이 넘었다. 두번째 회사에 다니고 있지만, 두 회사 모두 닷넷 기술을 사용하여서, 닷넷은 나름 빠삭(?)하다 생각하지만 Java, Python, GO lang등 다른 언어나 기술 환경은 잘 모르는 처지가 되었다. </p>
<p>요즘 <a href="http://en.wikipedia.org/wiki/Polyglot_(computing" target="_blank" rel="noopener">폴리글랏</a> 프로그래머가 유행이라던데, 개인적으로 만드려고 했던 서비스를 만들면서, 닷넷을 벗어나 새로운 언어와 환경에서 만들기로 하고, 평소 관심을 가지고 있었던 node.js를 공부해 보기로 하였다.</p>
<h2 id="node-js-개요"><a href="#node-js-개요" class="headerlink" title="node.js 개요"></a>node.js 개요</h2><p>node.js는 서버사이드에서 동작하는 javascript이다. 브라우저에서 주로 사용되는 javascript가 어떻게 서버사이드에서 동작하는 것일까? 답은 바로 <a href="http://ko.wikipedia.org/wiki/V8_(%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%97%94%EC%A7%84" target="_blank" rel="noopener">Google V8</a>)(자바스크립트 엔진) 덕분이다. V8은 javascript를 JIT 컴파일하여 빠른 속도로 실행시켜주는 엔진이고, 크롬에서도 쓰이고 있으며, 오픈소스로 공개함으로써 브라우저의 전유물이었던 javascript를 외부에서 사용 할 수 있는 길을 열었다.<br>node.js를 만든 Ryan Dahl(라이언달)도 반응성이 뛰어난 애플리케이션을 만들려고 하였을 때, V8을 써서 javascript의 비동기(async)를 이용한 node를 개발 할 수 있었다. </p>
<p><a href="http://holgerblank.com/2009/speaker/speakers_selected.html" target="_blank" rel="noopener">JSconf EU 2009</a> 행사에서 라이언달(Ryan Dahl)이라는 개발자가 Node.js, Evented I/O for V8 Javascript라는 세션을 발표한다.<br>이 발표에서 라이언달은 node.js를 javascript를 이용해 I/O 프로그래밍을 할 수 있고, 개발에 있어 성능을 높이는데 집중했다고 한다.</p>
<h2 id="node-js-설치"><a href="#node-js-설치" class="headerlink" title="node.js 설치"></a>node.js 설치</h2><p>ubuntu 14.04 LTS(64bit)에 node.js 설치해보자.</p>
<h3 id="apt-get-Advanced-Packaging-Tool-을-이용하여-설치"><a href="#apt-get-Advanced-Packaging-Tool-을-이용하여-설치" class="headerlink" title="apt-get(Advanced Packaging Tool)을 이용하여 설치"></a>apt-get(Advanced Packaging Tool)을 이용하여 설치</h3><p>apt-get을 통해 설치하는것이 여러모로 편리하지만 한가지 주의 할 사항이 있다. 기본 repository에 있는 node.js 버전이 최신버전이 아닐 수 있다는 점이다.<br>오늘(2015-06-02) 기준으로 node.js 사이트에서 확인한 버전은 v0.12.4 버전이다. 그런 ubuntu 기본 repository에는 어떤 버전의 node.js가 있는지 확인 해 보자</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get udpate    </span><br><span class="line">sudo apt-cache policy nodejs</span><br></pre></td></tr></table></figure>
<p>위의 명령을 통해 확인해 보면 다음과 같이 v0.10.25버전이 들어있는 것을 알 수 있다.<br><img src="http://i.imgur.com/RGcHs3R.png" alt=""></p>
<p>그럼 최신버전의 node.js를 apt-get을 통해 설치하려면 어떻게 해야할까?</p>
<p>기본적으로 apt-get을 사용하면 ubuntu에서 공식 운영하는 repository를 사용하여 다운로드 받게 된다. PPA(personal package archive)는 사설로 운영하는 저장소인데 node.js의 최신버전은 NodeSource라는 곳에서 관리한다.  </p>
<p>다음과 같이 node.js의 PPA를 추가한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_dev | sudo bash -</span><br></pre></td></tr></table></figure>
<p>그리고 다시 apt package의 node 버전을 확인해 보면 다음과 같이 v0.12.4 인것을 확인 할 수 있다. 최신버전을 설치하기 위한 사전작업은 끝났다.  apt-get을 사용하여 설치해 보자.<br><img src="http://i.imgur.com/eImMCUK.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure>
<p>이렇게 설치하면 node.js와 npm(node package manager)가 함께 설치된다.<br>설치를 마쳤다면 node -v이라고 입력하여 설치된 버전을 확인 할 수 있다.</p>
<p>ps. node.js는 여러버전을 중복하여 설치 할 수 있는데 NVM (node version manager)을 이용하면 좀 더 쉽게 설치 및 버전 관리가 가능하다.(시간이 된다면 소개하겠다).</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2015/06/03/install-nodejs/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Hojin Jun. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/3b2b21d1b33d50542a9c5642c6b5d64d?s=110" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Hojin Jun</h4>
        
            <div id="about-card-bio"></div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>programmer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
